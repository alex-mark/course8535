
my_curs.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001040  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000de  00800060  00001040  000010d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000009  0080013e  0080013e  000011b2  2**0
                  ALLOC
  3 .debug_aranges 00000060  00000000  00000000  000011b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000394  00000000  00000000  00001212  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000f64  00000000  00000000  000015a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000712  00000000  00000000  0000250a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000fb9  00000000  00000000  00002c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002f0  00000000  00000000  00003bd8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000443  00000000  00000000  00003ec8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000007fb  00000000  00000000  0000430b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a8  00000000  00000000  00004b06  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
       2:	2b c0       	rjmp	.+86     	; 0x5a <__bad_interrupt>
       4:	2a c0       	rjmp	.+84     	; 0x5a <__bad_interrupt>
       6:	29 c0       	rjmp	.+82     	; 0x5a <__bad_interrupt>
       8:	28 c0       	rjmp	.+80     	; 0x5a <__bad_interrupt>
       a:	27 c0       	rjmp	.+78     	; 0x5a <__bad_interrupt>
       c:	58 c1       	rjmp	.+688    	; 0x2be <__vector_6>
       e:	25 c0       	rjmp	.+74     	; 0x5a <__bad_interrupt>
      10:	24 c0       	rjmp	.+72     	; 0x5a <__bad_interrupt>
      12:	23 c0       	rjmp	.+70     	; 0x5a <__bad_interrupt>
      14:	22 c0       	rjmp	.+68     	; 0x5a <__bad_interrupt>
      16:	21 c0       	rjmp	.+66     	; 0x5a <__bad_interrupt>
      18:	20 c0       	rjmp	.+64     	; 0x5a <__bad_interrupt>
      1a:	1f c0       	rjmp	.+62     	; 0x5a <__bad_interrupt>
      1c:	1e c0       	rjmp	.+60     	; 0x5a <__bad_interrupt>
      1e:	1d c0       	rjmp	.+58     	; 0x5a <__bad_interrupt>
      20:	1c c0       	rjmp	.+56     	; 0x5a <__bad_interrupt>

00000022 <__ctors_end>:
      22:	11 24       	eor	r1, r1
      24:	1f be       	out	0x3f, r1	; 63
      26:	cf e5       	ldi	r28, 0x5F	; 95
      28:	d2 e0       	ldi	r29, 0x02	; 2
      2a:	de bf       	out	0x3e, r29	; 62
      2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_copy_data>:
      2e:	11 e0       	ldi	r17, 0x01	; 1
      30:	a0 e6       	ldi	r26, 0x60	; 96
      32:	b0 e0       	ldi	r27, 0x00	; 0
      34:	e0 e4       	ldi	r30, 0x40	; 64
      36:	f0 e1       	ldi	r31, 0x10	; 16
      38:	03 c0       	rjmp	.+6      	; 0x40 <.do_copy_data_start>

0000003a <.do_copy_data_loop>:
      3a:	c8 95       	lpm
      3c:	31 96       	adiw	r30, 0x01	; 1
      3e:	0d 92       	st	X+, r0

00000040 <.do_copy_data_start>:
      40:	ae 33       	cpi	r26, 0x3E	; 62
      42:	b1 07       	cpc	r27, r17
      44:	d1 f7       	brne	.-12     	; 0x3a <.do_copy_data_loop>

00000046 <__do_clear_bss>:
      46:	11 e0       	ldi	r17, 0x01	; 1
      48:	ae e3       	ldi	r26, 0x3E	; 62
      4a:	b1 e0       	ldi	r27, 0x01	; 1
      4c:	01 c0       	rjmp	.+2      	; 0x50 <.do_clear_bss_start>

0000004e <.do_clear_bss_loop>:
      4e:	1d 92       	st	X+, r1

00000050 <.do_clear_bss_start>:
      50:	a7 34       	cpi	r26, 0x47	; 71
      52:	b1 07       	cpc	r27, r17
      54:	e1 f7       	brne	.-8      	; 0x4e <.do_clear_bss_loop>
      56:	5f d2       	rcall	.+1214   	; 0x516 <main>
      58:	f1 c7       	rjmp	.+4066   	; 0x103c <_exit>

0000005a <__bad_interrupt>:
      5a:	d2 cf       	rjmp	.-92     	; 0x0 <__vectors>

0000005c <loop>:

    sei();	// set enable interrupts
}

void loop()
{	
      5c:	ff cf       	rjmp	.-2      	; 0x5c <loop>

0000005e <UART_init>:

/* Initialize UART */
void UART_init( unsigned int baud_prescaler )
{
	/* Set the baud rate */
	UBRR = (unsigned char) baud_prescaler;
      5e:	89 b9       	out	0x09, r24	; 9
	
	/* Enable UART receiver and transmitter */
	UCR = (( 1 << RXEN ) | ( 1 << TXEN ) | ( 1 << TXB8 ) | (1 << RXB8)); 
      60:	8b e1       	ldi	r24, 0x1B	; 27
      62:	8a b9       	out	0x0a, r24	; 10
}
      64:	08 95       	ret

00000066 <timer0_init>:

/* Initialize Timer0 */
void timer0_init()
{
	//	set up timer with no prescaling
	TCCR0 |= (1 << CS00);
      66:	83 b7       	in	r24, 0x33	; 51
      68:	81 60       	ori	r24, 0x01	; 1
      6a:	83 bf       	out	0x33, r24	; 51
	
	//	set timer0 counter initial value to TIMER_START
	TCNT0 = TIMER_START;
      6c:	88 ed       	ldi	r24, 0xD8	; 216
      6e:	82 bf       	out	0x32, r24	; 50

	//	enable interrupt for timer0
	//TIMSK |= (1<<TOIE0);
}
      70:	08 95       	ret

00000072 <timer1_init>:

void timer1_init()
{
	// set up timer with prescaler = 8 and CTC mode
    TCCR1B |= (1 << CTC1) | (1 << CS11);
      72:	8e b5       	in	r24, 0x2e	; 46
      74:	8a 60       	ori	r24, 0x0A	; 10
      76:	8e bd       	out	0x2e, r24	; 46
  
    // initialize counter
    TCNT1 = 0;
      78:	1d bc       	out	0x2d, r1	; 45
      7a:	1c bc       	out	0x2c, r1	; 44
  
    // initialize compare value
    OCR1A = 10000; // 6000 working fine
      7c:	80 e1       	ldi	r24, 0x10	; 16
      7e:	97 e2       	ldi	r25, 0x27	; 39
      80:	9b bd       	out	0x2b, r25	; 43
      82:	8a bd       	out	0x2a, r24	; 42
  
    // enable compare interrupt
    TIMSK |= (1 << OCIE1A);
      84:	89 b7       	in	r24, 0x39	; 57
      86:	80 61       	ori	r24, 0x10	; 16
      88:	89 bf       	out	0x39, r24	; 57
}
      8a:	08 95       	ret

0000008c <adc_init>:

void adc_init()		//initialization of ADC
{
	ADCSR |= (1 << ADEN);  // Enable ADC
      8c:	37 9a       	sbi	0x06, 7	; 6

	ADCSR |= (1 << ADPS2) | (1 << ADPS0); // Set ADC prescaler to 32 - 125KHz sample rate @ 4MHz
      8e:	86 b1       	in	r24, 0x06	; 6
      90:	85 60       	ori	r24, 0x05	; 5
      92:	86 b9       	out	0x06, r24	; 6

	ADMUX = 0; //Binary equivalent of										  
      94:	17 b8       	out	0x07, r1	; 7
	//ADCSR |= (1 << ADFR);  // Set ADC to Free-Running Mode
	
	//ADCSR |= (1 << ADIE);  // Enable ADC Interrupt

	//ADCSR |= (1 << ADSC);  // Start A2D Conversions
}
      96:	08 95       	ret

00000098 <UART_receive>:

/* Read and write functions */
unsigned char UART_receive( void )
{
	/* Wait for incomming data */
	while ( !(USR & (1<<RXC)) ) 	
      98:	5f 9b       	sbis	0x0b, 7	; 11
      9a:	fe cf       	rjmp	.-4      	; 0x98 <UART_receive>
		;			                
	/* Return the data */
	return UDR;
      9c:	8c b1       	in	r24, 0x0c	; 12
}
      9e:	08 95       	ret

000000a0 <UART_transmit>:

void UART_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !(USR & (1<<UDRE)) );
      a0:	5d 9b       	sbis	0x0b, 5	; 11
      a2:	fe cf       	rjmp	.-4      	; 0xa0 <UART_transmit>

	/* Start transmittion */
	UDR = data; 		
      a4:	8c b9       	out	0x0c, r24	; 12
}
      a6:	08 95       	ret

000000a8 <UART_transmit_string>:

void UART_transmit_string(char *str)
{
	int i;
	for (i = 0; i < strlen(str); i++){
      a8:	e8 2f       	mov	r30, r24
      aa:	f9 2f       	mov	r31, r25
      ac:	ae 2f       	mov	r26, r30
      ae:	bf 2f       	mov	r27, r31
      b0:	0d 90       	ld	r0, X+
      b2:	00 20       	and	r0, r0
      b4:	e9 f7       	brne	.-6      	; 0xb0 <UART_transmit_string+0x8>
      b6:	11 97       	sbiw	r26, 0x01	; 1
      b8:	ae 1b       	sub	r26, r30
      ba:	bf 0b       	sbc	r27, r31
      bc:	20 e0       	ldi	r18, 0x00	; 0
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	0a c0       	rjmp	.+20     	; 0xd6 <UART_transmit_string+0x2e>
		UART_transmit(str[i]);
      c2:	e8 2f       	mov	r30, r24
      c4:	f9 2f       	mov	r31, r25
      c6:	e2 0f       	add	r30, r18
      c8:	f3 1f       	adc	r31, r19
      ca:	e0 81       	ld	r30, Z
}

void UART_transmit(unsigned char data)
{
	/* Wait for empty transmit buffer */
	while ( !(USR & (1<<UDRE)) );
      cc:	5d 9b       	sbis	0x0b, 5	; 11
      ce:	fe cf       	rjmp	.-4      	; 0xcc <UART_transmit_string+0x24>

	/* Start transmittion */
	UDR = data; 		
      d0:	ec b9       	out	0x0c, r30	; 12
}

void UART_transmit_string(char *str)
{
	int i;
	for (i = 0; i < strlen(str); i++){
      d2:	2f 5f       	subi	r18, 0xFF	; 255
      d4:	3f 4f       	sbci	r19, 0xFF	; 255
      d6:	2a 17       	cp	r18, r26
      d8:	3b 07       	cpc	r19, r27
      da:	98 f3       	brcs	.-26     	; 0xc2 <UART_transmit_string+0x1a>
		UART_transmit(str[i]);
	}
	//_delay_ms(500);
}
      dc:	08 95       	ret

000000de <uart_transmit_adc64>:
	}
}

// transmit 64 bytes (8x8) via uart
void uart_transmit_adc64(uint8_t page_adc_vals[][8])
{
      de:	8f 92       	push	r8
      e0:	9f 92       	push	r9
      e2:	af 92       	push	r10
      e4:	bf 92       	push	r11
      e6:	cf 92       	push	r12
      e8:	df 92       	push	r13
      ea:	ef 92       	push	r14
      ec:	ff 92       	push	r15
      ee:	0f 93       	push	r16
      f0:	1f 93       	push	r17
      f2:	df 93       	push	r29
      f4:	cf 93       	push	r28
      f6:	cd b7       	in	r28, 0x3d	; 61
      f8:	de b7       	in	r29, 0x3e	; 62
      fa:	e2 97       	sbiw	r28, 0x32	; 50
      fc:	0f b6       	in	r0, 0x3f	; 63
      fe:	f8 94       	cli
     100:	de bf       	out	0x3e, r29	; 62
     102:	0f be       	out	0x3f, r0	; 63
     104:	cd bf       	out	0x3d, r28	; 61
     106:	c8 2e       	mov	r12, r24
     108:	d9 2e       	mov	r13, r25
     10a:	ee 24       	eor	r14, r14
     10c:	ff 24       	eor	r15, r15
	char buffer[50];
	for (int i = 0; i < 8; i++){
		for (int j = 0; j < 8; j++){
			sprintf(buffer, "%i: %3d mV  ", j, page_adc_vals[i][j]);
     10e:	ac 2e       	mov	r10, r28
     110:	bd 2e       	mov	r11, r29
     112:	08 94       	sec
     114:	a1 1c       	adc	r10, r1
     116:	b1 1c       	adc	r11, r1
     118:	80 e6       	ldi	r24, 0x60	; 96
     11a:	88 2e       	mov	r8, r24
     11c:	80 e0       	ldi	r24, 0x00	; 0
     11e:	98 2e       	mov	r9, r24
     120:	48 c0       	rjmp	.+144    	; 0x1b2 <uart_transmit_adc64+0xd4>
     122:	8d b7       	in	r24, 0x3d	; 61
     124:	9e b7       	in	r25, 0x3e	; 62
     126:	08 97       	sbiw	r24, 0x08	; 8
     128:	0f b6       	in	r0, 0x3f	; 63
     12a:	f8 94       	cli
     12c:	9e bf       	out	0x3e, r25	; 62
     12e:	0f be       	out	0x3f, r0	; 63
     130:	8d bf       	out	0x3d, r24	; 61
     132:	ed b7       	in	r30, 0x3d	; 61
     134:	fe b7       	in	r31, 0x3e	; 62
     136:	31 96       	adiw	r30, 0x01	; 1
     138:	ad b7       	in	r26, 0x3d	; 61
     13a:	be b7       	in	r27, 0x3e	; 62
     13c:	12 96       	adiw	r26, 0x02	; 2
     13e:	bc 92       	st	X, r11
     140:	ae 92       	st	-X, r10
     142:	11 97       	sbiw	r26, 0x01	; 1
     144:	93 82       	std	Z+3, r9	; 0x03
     146:	82 82       	std	Z+2, r8	; 0x02
     148:	15 83       	std	Z+5, r17	; 0x05
     14a:	04 83       	std	Z+4, r16	; 0x04
     14c:	ac 2d       	mov	r26, r12
     14e:	bd 2d       	mov	r27, r13
     150:	a0 0f       	add	r26, r16
     152:	b1 1f       	adc	r27, r17
     154:	8c 91       	ld	r24, X
     156:	86 83       	std	Z+6, r24	; 0x06
     158:	17 82       	std	Z+7, r1	; 0x07
     15a:	60 d4       	rcall	.+2240   	; 0xa1c <sprintf>
			UART_transmit_string(buffer);
     15c:	8d b7       	in	r24, 0x3d	; 61
     15e:	9e b7       	in	r25, 0x3e	; 62
     160:	08 96       	adiw	r24, 0x08	; 8
     162:	0f b6       	in	r0, 0x3f	; 63
     164:	f8 94       	cli
     166:	9e bf       	out	0x3e, r25	; 62
     168:	0f be       	out	0x3f, r0	; 63
     16a:	8d bf       	out	0x3d, r24	; 61
     16c:	8a 2d       	mov	r24, r10
     16e:	9b 2d       	mov	r25, r11
     170:	9b df       	rcall	.-202    	; 0xa8 <UART_transmit_string>
			if (j == 3){
     172:	03 30       	cpi	r16, 0x03	; 3
     174:	11 05       	cpc	r17, r1
     176:	19 f4       	brne	.+6      	; 0x17e <uart_transmit_adc64+0xa0>
				UART_transmit_string("\r\n");
     178:	8d e6       	ldi	r24, 0x6D	; 109
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	95 df       	rcall	.-214    	; 0xa8 <UART_transmit_string>
// transmit 64 bytes (8x8) via uart
void uart_transmit_adc64(uint8_t page_adc_vals[][8])
{
	char buffer[50];
	for (int i = 0; i < 8; i++){
		for (int j = 0; j < 8; j++){
     17e:	0f 5f       	subi	r16, 0xFF	; 255
     180:	1f 4f       	sbci	r17, 0xFF	; 255
     182:	08 30       	cpi	r16, 0x08	; 8
     184:	11 05       	cpc	r17, r1
     186:	69 f6       	brne	.-102    	; 0x122 <uart_transmit_adc64+0x44>
			UART_transmit_string(buffer);
			if (j == 3){
				UART_transmit_string("\r\n");
			}
		}
		if (i < 7){
     188:	97 e0       	ldi	r25, 0x07	; 7
     18a:	e9 16       	cp	r14, r25
     18c:	f1 04       	cpc	r15, r1
     18e:	19 f0       	breq	.+6      	; 0x196 <uart_transmit_adc64+0xb8>
			UART_transmit_string("\r\n------------------------------------------\r\n");
     190:	80 e7       	ldi	r24, 0x70	; 112
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	02 c0       	rjmp	.+4      	; 0x19a <uart_transmit_adc64+0xbc>
		}else{
			UART_transmit_string("\r\n******************************************\r\n\r\n");
     196:	8f e9       	ldi	r24, 0x9F	; 159
     198:	90 e0       	ldi	r25, 0x00	; 0
     19a:	86 df       	rcall	.-244    	; 0xa8 <UART_transmit_string>

// transmit 64 bytes (8x8) via uart
void uart_transmit_adc64(uint8_t page_adc_vals[][8])
{
	char buffer[50];
	for (int i = 0; i < 8; i++){
     19c:	08 94       	sec
     19e:	e1 1c       	adc	r14, r1
     1a0:	f1 1c       	adc	r15, r1
     1a2:	a8 e0       	ldi	r26, 0x08	; 8
     1a4:	b0 e0       	ldi	r27, 0x00	; 0
     1a6:	ca 0e       	add	r12, r26
     1a8:	db 1e       	adc	r13, r27
     1aa:	b8 e0       	ldi	r27, 0x08	; 8
     1ac:	eb 16       	cp	r14, r27
     1ae:	f1 04       	cpc	r15, r1
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <uart_transmit_adc64+0xda>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
     1b6:	b5 cf       	rjmp	.-150    	; 0x122 <uart_transmit_adc64+0x44>
			UART_transmit_string("\r\n------------------------------------------\r\n");
		}else{
			UART_transmit_string("\r\n******************************************\r\n\r\n");
		}
	}
}
     1b8:	e2 96       	adiw	r28, 0x32	; 50
     1ba:	0f b6       	in	r0, 0x3f	; 63
     1bc:	f8 94       	cli
     1be:	de bf       	out	0x3e, r29	; 62
     1c0:	0f be       	out	0x3f, r0	; 63
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	cf 91       	pop	r28
     1c6:	df 91       	pop	r29
     1c8:	1f 91       	pop	r17
     1ca:	0f 91       	pop	r16
     1cc:	ff 90       	pop	r15
     1ce:	ef 90       	pop	r14
     1d0:	df 90       	pop	r13
     1d2:	cf 90       	pop	r12
     1d4:	bf 90       	pop	r11
     1d6:	af 90       	pop	r10
     1d8:	9f 90       	pop	r9
     1da:	8f 90       	pop	r8
     1dc:	08 95       	ret

000001de <get_adc_vals>:
		eeprom_pointer = get_eeprom_start_pointer();
	}
}

void get_adc_vals(uint8_t *port_adc_vals)
{
     1de:	8f 92       	push	r8
     1e0:	9f 92       	push	r9
     1e2:	af 92       	push	r10
     1e4:	bf 92       	push	r11
     1e6:	df 92       	push	r13
     1e8:	ef 92       	push	r14
     1ea:	ff 92       	push	r15
     1ec:	0f 93       	push	r16
     1ee:	1f 93       	push	r17
     1f0:	df 93       	push	r29
     1f2:	cf 93       	push	r28
     1f4:	cd b7       	in	r28, 0x3d	; 61
     1f6:	de b7       	in	r29, 0x3e	; 62
     1f8:	2a 97       	sbiw	r28, 0x0a	; 10
     1fa:	0f b6       	in	r0, 0x3f	; 63
     1fc:	f8 94       	cli
     1fe:	de bf       	out	0x3e, r29	; 62
     200:	0f be       	out	0x3f, r0	; 63
     202:	cd bf       	out	0x3d, r28	; 61
     204:	e8 2e       	mov	r14, r24
     206:	f9 2e       	mov	r15, r25
     208:	00 e0       	ldi	r16, 0x00	; 0
     20a:	10 e0       	ldi	r17, 0x00	; 0
		port_adc_vals[i] = adc_value;

		//sprintf(buffer, "%d: %d\r\n", i, adc_value);
		//UART_transmit_string(buffer);

		sprintf(buffer, "%3d", adc_value);
     20c:	ac 2e       	mov	r10, r28
     20e:	bd 2e       	mov	r11, r29
     210:	08 94       	sec
     212:	a1 1c       	adc	r10, r1
     214:	b1 1c       	adc	r11, r1
     216:	90 ed       	ldi	r25, 0xD0	; 208
     218:	89 2e       	mov	r8, r25
     21a:	90 e0       	ldi	r25, 0x00	; 0
     21c:	99 2e       	mov	r9, r25
		eeprom_pointer = get_eeprom_start_pointer();
	}
}

void get_adc_vals(uint8_t *port_adc_vals)
{
     21e:	d0 2e       	mov	r13, r16
	char buffer[10];
	uint8_t adc_value;

	for (int i = 0; i < 8; i++){
		ADMUX = i;
     220:	07 b9       	out	0x07, r16	; 7
		ADCSR |= (1 << ADSC);
     222:	36 9a       	sbi	0x06, 6	; 6
		while(ADCSR & (1<<ADSC));
     224:	36 99       	sbic	0x06, 6	; 6
     226:	fe cf       	rjmp	.-4      	; 0x224 <get_adc_vals+0x46>
		adc_value = ADCW * 250 / 127; //equals mult 250 div 128 to get 250 mV
     228:	84 b1       	in	r24, 0x04	; 4
     22a:	95 b1       	in	r25, 0x05	; 5
     22c:	6a ef       	ldi	r22, 0xFA	; 250
     22e:	70 e0       	ldi	r23, 0x00	; 0
     230:	cd d3       	rcall	.+1946   	; 0x9cc <__mulhi3>
     232:	6f e7       	ldi	r22, 0x7F	; 127
     234:	70 e0       	ldi	r23, 0x00	; 0
     236:	dc d3       	rcall	.+1976   	; 0x9f0 <__udivmodhi4>
		port_adc_vals[i] = adc_value;
     238:	ae 2d       	mov	r26, r14
     23a:	bf 2d       	mov	r27, r15
     23c:	6c 93       	st	X, r22

		//sprintf(buffer, "%d: %d\r\n", i, adc_value);
		//UART_transmit_string(buffer);

		sprintf(buffer, "%3d", adc_value);
     23e:	00 d0       	rcall	.+0      	; 0x240 <get_adc_vals+0x62>
     240:	00 d0       	rcall	.+0      	; 0x242 <get_adc_vals+0x64>
     242:	00 d0       	rcall	.+0      	; 0x244 <get_adc_vals+0x66>
     244:	ed b7       	in	r30, 0x3d	; 61
     246:	fe b7       	in	r31, 0x3e	; 62
     248:	31 96       	adiw	r30, 0x01	; 1
     24a:	ad b7       	in	r26, 0x3d	; 61
     24c:	be b7       	in	r27, 0x3e	; 62
     24e:	12 96       	adiw	r26, 0x02	; 2
     250:	bc 92       	st	X, r11
     252:	ae 92       	st	-X, r10
     254:	11 97       	sbiw	r26, 0x01	; 1
     256:	93 82       	std	Z+3, r9	; 0x03
     258:	82 82       	std	Z+2, r8	; 0x02
     25a:	64 83       	std	Z+4, r22	; 0x04
     25c:	15 82       	std	Z+5, r1	; 0x05
     25e:	de d3       	rcall	.+1980   	; 0xa1c <sprintf>
		if (i < 4){
     260:	ed b7       	in	r30, 0x3d	; 61
     262:	fe b7       	in	r31, 0x3e	; 62
     264:	36 96       	adiw	r30, 0x06	; 6
     266:	0f b6       	in	r0, 0x3f	; 63
     268:	f8 94       	cli
     26a:	fe bf       	out	0x3e, r31	; 62
     26c:	0f be       	out	0x3f, r0	; 63
     26e:	ed bf       	out	0x3d, r30	; 61
     270:	04 30       	cpi	r16, 0x04	; 4
     272:	11 05       	cpc	r17, r1
     274:	14 f4       	brge	.+4      	; 0x27a <__stack+0x1b>
			lcd_gotoxy(2, i); // start writing after number of port "#:"
     276:	82 e0       	ldi	r24, 0x02	; 2
     278:	03 c0       	rjmp	.+6      	; 0x280 <__stack+0x21>
		}else{
			lcd_gotoxy(10, i - 4);
     27a:	fc ef       	ldi	r31, 0xFC	; 252
     27c:	df 0e       	add	r13, r31
     27e:	8a e0       	ldi	r24, 0x0A	; 10
     280:	6d 2d       	mov	r22, r13
     282:	1c d3       	rcall	.+1592   	; 0x8bc <lcd_gotoxy>
		}
		lcd_puts(buffer);
     284:	8a 2d       	mov	r24, r10
     286:	9b 2d       	mov	r25, r11
     288:	4e d3       	rcall	.+1692   	; 0x926 <lcd_puts>
void get_adc_vals(uint8_t *port_adc_vals)
{
	char buffer[10];
	uint8_t adc_value;

	for (int i = 0; i < 8; i++){
     28a:	0f 5f       	subi	r16, 0xFF	; 255
     28c:	1f 4f       	sbci	r17, 0xFF	; 255
     28e:	08 94       	sec
     290:	e1 1c       	adc	r14, r1
     292:	f1 1c       	adc	r15, r1
     294:	08 30       	cpi	r16, 0x08	; 8
     296:	11 05       	cpc	r17, r1
     298:	11 f6       	brne	.-124    	; 0x21e <get_adc_vals+0x40>
		}else{
			lcd_gotoxy(10, i - 4);
		}
		lcd_puts(buffer);
	}
}
     29a:	2a 96       	adiw	r28, 0x0a	; 10
     29c:	0f b6       	in	r0, 0x3f	; 63
     29e:	f8 94       	cli
     2a0:	de bf       	out	0x3e, r29	; 62
     2a2:	0f be       	out	0x3f, r0	; 63
     2a4:	cd bf       	out	0x3d, r28	; 61
     2a6:	cf 91       	pop	r28
     2a8:	df 91       	pop	r29
     2aa:	1f 91       	pop	r17
     2ac:	0f 91       	pop	r16
     2ae:	ff 90       	pop	r15
     2b0:	ef 90       	pop	r14
     2b2:	df 90       	pop	r13
     2b4:	bf 90       	pop	r11
     2b6:	af 90       	pop	r10
     2b8:	9f 90       	pop	r9
     2ba:	8f 90       	pop	r8
     2bc:	08 95       	ret

000002be <__vector_6>:
		lcd_puts(str);
	}	
}

ISR (TIMER1_COMPA_vect)
{
     2be:	1f 92       	push	r1
     2c0:	0f 92       	push	r0
     2c2:	0f b6       	in	r0, 0x3f	; 63
     2c4:	0f 92       	push	r0
     2c6:	11 24       	eor	r1, r1
     2c8:	0f 93       	push	r16
     2ca:	1f 93       	push	r17
     2cc:	2f 93       	push	r18
     2ce:	3f 93       	push	r19
     2d0:	4f 93       	push	r20
     2d2:	5f 93       	push	r21
     2d4:	6f 93       	push	r22
     2d6:	7f 93       	push	r23
     2d8:	8f 93       	push	r24
     2da:	9f 93       	push	r25
     2dc:	af 93       	push	r26
     2de:	bf 93       	push	r27
     2e0:	ef 93       	push	r30
     2e2:	ff 93       	push	r31
     2e4:	df 93       	push	r29
     2e6:	cf 93       	push	r28
     2e8:	cd b7       	in	r28, 0x3d	; 61
     2ea:	de b7       	in	r29, 0x3e	; 62
     2ec:	ca 57       	subi	r28, 0x7A	; 122
     2ee:	d0 40       	sbci	r29, 0x00	; 0
     2f0:	de bf       	out	0x3e, r29	; 62
     2f2:	cd bf       	out	0x3d, r28	; 61
	uint8_t port_adc_vals[8];
	
	char buffer[50];

	// if true it's time to read from memory and send via uart
	if (eeprom_write_counter >= 8){
     2f4:	80 91 3e 01 	lds	r24, 0x013E
     2f8:	88 30       	cpi	r24, 0x08	; 8
     2fa:	90 f0       	brcs	.+36     	; 0x320 <__vector_6+0x62>
		if (eeprom_pointer >= 64){ // check for end of a memory
     2fc:	60 91 41 01 	lds	r22, 0x0141
     300:	70 91 42 01 	lds	r23, 0x0142
     304:	8c 2f       	mov	r24, r28
     306:	9d 2f       	mov	r25, r29
     308:	cb 96       	adiw	r24, 0x3b	; 59
     30a:	60 34       	cpi	r22, 0x40	; 64
     30c:	71 05       	cpc	r23, r1
     30e:	18 f0       	brcs	.+6      	; 0x316 <__vector_6+0x58>
			read_page_eeprom(*page_adc_vals, eeprom_pointer - EEPROM_PAGE_SIZE, EEPROM_PAGE_SIZE);
     310:	60 54       	subi	r22, 0x40	; 64
     312:	70 40       	sbci	r23, 0x00	; 0
     314:	02 c0       	rjmp	.+4      	; 0x31a <__vector_6+0x5c>
		}else{
			read_page_eeprom(*page_adc_vals, EEPROM_SIZE - EEPROM_PAGE_SIZE, EEPROM_PAGE_SIZE);
     316:	60 ec       	ldi	r22, 0xC0	; 192
     318:	7f e7       	ldi	r23, 0x7F	; 127
     31a:	40 e4       	ldi	r20, 0x40	; 64
     31c:	50 e0       	ldi	r21, 0x00	; 0
     31e:	05 d2       	rcall	.+1034   	; 0x72a <read_page_eeprom>
		}
		
	}

	get_adc_vals(port_adc_vals);
     320:	0c 2f       	mov	r16, r28
     322:	1d 2f       	mov	r17, r29
     324:	0f 5f       	subi	r16, 0xFF	; 255
     326:	1f 4f       	sbci	r17, 0xFF	; 255
     328:	80 2f       	mov	r24, r16
     32a:	91 2f       	mov	r25, r17
     32c:	58 df       	rcall	.-336    	; 0x1de <get_adc_vals>
	write_page_eeprom(eeprom_pointer, port_adc_vals, 8);
     32e:	80 91 41 01 	lds	r24, 0x0141
     332:	90 91 42 01 	lds	r25, 0x0142
     336:	60 2f       	mov	r22, r16
     338:	71 2f       	mov	r23, r17
     33a:	48 e0       	ldi	r20, 0x08	; 8
     33c:	50 e0       	ldi	r21, 0x00	; 0
     33e:	a1 d1       	rcall	.+834    	; 0x682 <write_page_eeprom>

	if (eeprom_write_counter >= 8){ // continue to send via uart
     340:	80 91 3e 01 	lds	r24, 0x013E
     344:	88 30       	cpi	r24, 0x08	; 8
     346:	70 f1       	brcs	.+92     	; 0x3a4 <__vector_6+0xe6>
		eeprom_write_counter = 0;
     348:	10 92 3e 01 	sts	0x013E, r1
		sprintf(buffer, "eeprom_pointer %X\r\n", eeprom_pointer - EEPROM_PAGE_SIZE);
     34c:	00 d0       	rcall	.+0      	; 0x34e <__vector_6+0x90>
     34e:	00 d0       	rcall	.+0      	; 0x350 <__vector_6+0x92>
     350:	00 d0       	rcall	.+0      	; 0x352 <__vector_6+0x94>
     352:	ed b7       	in	r30, 0x3d	; 61
     354:	fe b7       	in	r31, 0x3e	; 62
     356:	31 96       	adiw	r30, 0x01	; 1
     358:	0c 2f       	mov	r16, r28
     35a:	1d 2f       	mov	r17, r29
     35c:	07 5f       	subi	r16, 0xF7	; 247
     35e:	1f 4f       	sbci	r17, 0xFF	; 255
     360:	ad b7       	in	r26, 0x3d	; 61
     362:	be b7       	in	r27, 0x3e	; 62
     364:	12 96       	adiw	r26, 0x02	; 2
     366:	1c 93       	st	X, r17
     368:	0e 93       	st	-X, r16
     36a:	11 97       	sbiw	r26, 0x01	; 1
     36c:	84 ed       	ldi	r24, 0xD4	; 212
     36e:	90 e0       	ldi	r25, 0x00	; 0
     370:	93 83       	std	Z+3, r25	; 0x03
     372:	82 83       	std	Z+2, r24	; 0x02
     374:	80 91 41 01 	lds	r24, 0x0141
     378:	90 91 42 01 	lds	r25, 0x0142
     37c:	80 54       	subi	r24, 0x40	; 64
     37e:	90 40       	sbci	r25, 0x00	; 0
     380:	95 83       	std	Z+5, r25	; 0x05
     382:	84 83       	std	Z+4, r24	; 0x04
     384:	4b d3       	rcall	.+1686   	; 0xa1c <sprintf>
		UART_transmit_string(buffer);
     386:	8d b7       	in	r24, 0x3d	; 61
     388:	9e b7       	in	r25, 0x3e	; 62
     38a:	06 96       	adiw	r24, 0x06	; 6
     38c:	0f b6       	in	r0, 0x3f	; 63
     38e:	f8 94       	cli
     390:	9e bf       	out	0x3e, r25	; 62
     392:	0f be       	out	0x3f, r0	; 63
     394:	8d bf       	out	0x3d, r24	; 61
     396:	80 2f       	mov	r24, r16
     398:	91 2f       	mov	r25, r17
     39a:	86 de       	rcall	.-756    	; 0xa8 <UART_transmit_string>
		uart_transmit_adc64(page_adc_vals);
     39c:	8c 2f       	mov	r24, r28
     39e:	9d 2f       	mov	r25, r29
     3a0:	cb 96       	adiw	r24, 0x3b	; 59
     3a2:	9d de       	rcall	.-710    	; 0xde <uart_transmit_adc64>
	}
	
	eeprom_write_counter++;
     3a4:	80 91 3e 01 	lds	r24, 0x013E
     3a8:	8f 5f       	subi	r24, 0xFF	; 255
     3aa:	80 93 3e 01 	sts	0x013E, r24
	if (eeprom_pointer < EEPROM_SIZE){ // check pointer for end of a memory
     3ae:	80 91 41 01 	lds	r24, 0x0141
     3b2:	90 91 42 01 	lds	r25, 0x0142
     3b6:	97 fd       	sbrc	r25, 7
     3b8:	02 c0       	rjmp	.+4      	; 0x3be <__vector_6+0x100>
		eeprom_pointer += 8;
     3ba:	08 96       	adiw	r24, 0x08	; 8
     3bc:	01 c0       	rjmp	.+2      	; 0x3c0 <__vector_6+0x102>
	}else{
		eeprom_pointer = get_eeprom_start_pointer();
     3be:	ad d0       	rcall	.+346    	; 0x51a <get_eeprom_start_pointer>
     3c0:	90 93 42 01 	sts	0x0142, r25
     3c4:	80 93 41 01 	sts	0x0141, r24
	}
}
     3c8:	c6 58       	subi	r28, 0x86	; 134
     3ca:	df 4f       	sbci	r29, 0xFF	; 255
     3cc:	de bf       	out	0x3e, r29	; 62
     3ce:	cd bf       	out	0x3d, r28	; 61
     3d0:	cf 91       	pop	r28
     3d2:	df 91       	pop	r29
     3d4:	ff 91       	pop	r31
     3d6:	ef 91       	pop	r30
     3d8:	bf 91       	pop	r27
     3da:	af 91       	pop	r26
     3dc:	9f 91       	pop	r25
     3de:	8f 91       	pop	r24
     3e0:	7f 91       	pop	r23
     3e2:	6f 91       	pop	r22
     3e4:	5f 91       	pop	r21
     3e6:	4f 91       	pop	r20
     3e8:	3f 91       	pop	r19
     3ea:	2f 91       	pop	r18
     3ec:	1f 91       	pop	r17
     3ee:	0f 91       	pop	r16
     3f0:	0f 90       	pop	r0
     3f2:	0f be       	out	0x3f, r0	; 63
     3f4:	0f 90       	pop	r0
     3f6:	1f 90       	pop	r1
     3f8:	18 95       	reti

000003fa <lcd_preparation_for_adc>:
	//ADCSR |= (1 << ADSC);  // Start A2D Conversions
}

// Getting 2 columns 4 lines with number of port
void lcd_preparation_for_adc()
{
     3fa:	cf 92       	push	r12
     3fc:	df 92       	push	r13
     3fe:	ef 92       	push	r14
     400:	ff 92       	push	r15
     402:	0f 93       	push	r16
     404:	1f 93       	push	r17
     406:	df 93       	push	r29
     408:	cf 93       	push	r28
     40a:	00 d0       	rcall	.+0      	; 0x40c <lcd_preparation_for_adc+0x12>
     40c:	00 d0       	rcall	.+0      	; 0x40e <lcd_preparation_for_adc+0x14>
     40e:	cd b7       	in	r28, 0x3d	; 61
     410:	de b7       	in	r29, 0x3e	; 62
	int i;
	char str[4] = "";
     412:	80 91 ec 00 	lds	r24, 0x00EC
     416:	90 91 ed 00 	lds	r25, 0x00ED
     41a:	a0 91 ee 00 	lds	r26, 0x00EE
     41e:	b0 91 ef 00 	lds	r27, 0x00EF
     422:	89 83       	std	Y+1, r24	; 0x01
     424:	9a 83       	std	Y+2, r25	; 0x02
     426:	ab 83       	std	Y+3, r26	; 0x03
     428:	bc 83       	std	Y+4, r27	; 0x04
	
	lcd_clrscr();
     42a:	5a d2       	rcall	.+1204   	; 0x8e0 <lcd_clrscr>
     42c:	00 e0       	ldi	r16, 0x00	; 0
     42e:	10 e0       	ldi	r17, 0x00	; 0

	for (i = 0; i < 8; i++){
		//itoa(i, str, 10);	// Here 10 means binary
		//strcat(str, ": ");
		sprintf(str,"%d:", i); // Getting string with number of port
     430:	ec 2e       	mov	r14, r28
     432:	fd 2e       	mov	r15, r29
     434:	08 94       	sec
     436:	e1 1c       	adc	r14, r1
     438:	f1 1c       	adc	r15, r1
     43a:	28 ee       	ldi	r18, 0xE8	; 232
     43c:	c2 2e       	mov	r12, r18
     43e:	20 e0       	ldi	r18, 0x00	; 0
     440:	d2 2e       	mov	r13, r18
     442:	00 d0       	rcall	.+0      	; 0x444 <lcd_preparation_for_adc+0x4a>
     444:	00 d0       	rcall	.+0      	; 0x446 <lcd_preparation_for_adc+0x4c>
     446:	00 d0       	rcall	.+0      	; 0x448 <lcd_preparation_for_adc+0x4e>
     448:	ed b7       	in	r30, 0x3d	; 61
     44a:	fe b7       	in	r31, 0x3e	; 62
     44c:	31 96       	adiw	r30, 0x01	; 1
     44e:	ad b7       	in	r26, 0x3d	; 61
     450:	be b7       	in	r27, 0x3e	; 62
     452:	12 96       	adiw	r26, 0x02	; 2
     454:	fc 92       	st	X, r15
     456:	ee 92       	st	-X, r14
     458:	11 97       	sbiw	r26, 0x01	; 1
     45a:	d3 82       	std	Z+3, r13	; 0x03
     45c:	c2 82       	std	Z+2, r12	; 0x02
     45e:	15 83       	std	Z+5, r17	; 0x05
     460:	04 83       	std	Z+4, r16	; 0x04
     462:	dc d2       	rcall	.+1464   	; 0xa1c <sprintf>
		
		if (i < 4){
     464:	8d b7       	in	r24, 0x3d	; 61
     466:	9e b7       	in	r25, 0x3e	; 62
     468:	06 96       	adiw	r24, 0x06	; 6
     46a:	0f b6       	in	r0, 0x3f	; 63
     46c:	f8 94       	cli
     46e:	9e bf       	out	0x3e, r25	; 62
     470:	0f be       	out	0x3f, r0	; 63
     472:	8d bf       	out	0x3d, r24	; 61
     474:	04 30       	cpi	r16, 0x04	; 4
     476:	11 05       	cpc	r17, r1
     478:	1c f4       	brge	.+6      	; 0x480 <lcd_preparation_for_adc+0x86>
			lcd_gotoxy(0,i);
     47a:	80 e0       	ldi	r24, 0x00	; 0
     47c:	60 2f       	mov	r22, r16
     47e:	03 c0       	rjmp	.+6      	; 0x486 <lcd_preparation_for_adc+0x8c>
		}else{
			lcd_gotoxy(8,i-4);
     480:	60 2f       	mov	r22, r16
     482:	64 50       	subi	r22, 0x04	; 4
     484:	88 e0       	ldi	r24, 0x08	; 8
     486:	1a d2       	rcall	.+1076   	; 0x8bc <lcd_gotoxy>
		}
		lcd_puts(str);
     488:	8e 2d       	mov	r24, r14
     48a:	9f 2d       	mov	r25, r15
     48c:	4c d2       	rcall	.+1176   	; 0x926 <lcd_puts>
	int i;
	char str[4] = "";
	
	lcd_clrscr();

	for (i = 0; i < 8; i++){
     48e:	0f 5f       	subi	r16, 0xFF	; 255
     490:	1f 4f       	sbci	r17, 0xFF	; 255
     492:	08 30       	cpi	r16, 0x08	; 8
     494:	11 05       	cpc	r17, r1
     496:	a9 f6       	brne	.-86     	; 0x442 <lcd_preparation_for_adc+0x48>
		}else{
			lcd_gotoxy(8,i-4);
		}
		lcd_puts(str);
	}	
}
     498:	0f 90       	pop	r0
     49a:	0f 90       	pop	r0
     49c:	0f 90       	pop	r0
     49e:	0f 90       	pop	r0
     4a0:	cf 91       	pop	r28
     4a2:	df 91       	pop	r29
     4a4:	1f 91       	pop	r17
     4a6:	0f 91       	pop	r16
     4a8:	ff 90       	pop	r15
     4aa:	ef 90       	pop	r14
     4ac:	df 90       	pop	r13
     4ae:	cf 90       	pop	r12
     4b0:	08 95       	ret

000004b2 <greeting>:
    	
}

void greeting()
{
	UART_transmit_string("                Hello!\r\n");
     4b2:	80 ef       	ldi	r24, 0xF0	; 240
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	f8 dd       	rcall	.-1040   	; 0xa8 <UART_transmit_string>
	UART_transmit_string("------------------------------------------\n\r");
     4b8:	89 e0       	ldi	r24, 0x09	; 9
     4ba:	91 e0       	ldi	r25, 0x01	; 1
     4bc:	f5 dd       	rcall	.-1046   	; 0xa8 <UART_transmit_string>

	lcd_clrscr();
     4be:	10 d2       	rcall	.+1056   	; 0x8e0 <lcd_clrscr>
	lcd_puts("Hello!");
     4c0:	86 e3       	ldi	r24, 0x36	; 54
     4c2:	91 e0       	ldi	r25, 0x01	; 1
     4c4:	30 d2       	rcall	.+1120   	; 0x926 <lcd_puts>
     4c6:	80 e1       	ldi	r24, 0x10	; 16
     4c8:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     4ca:	24 e6       	ldi	r18, 0x64	; 100
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	e2 2f       	mov	r30, r18
     4d0:	f3 2f       	mov	r31, r19
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	f1 f7       	brne	.-4      	; 0x4d2 <greeting+0x20>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     4d6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     4d8:	d1 f7       	brne	.-12     	; 0x4ce <greeting+0x1c>
	_delay_ms(1000);
}
     4da:	08 95       	ret

000004dc <setup>:
void setup()
{
	//int i;
	//uint8_t page_adc_vals[8][8];
	
	cli();	// clear enable interrupts
     4dc:	f8 94       	cli

/* Initialize UART */
void UART_init( unsigned int baud_prescaler )
{
	/* Set the baud rate */
	UBRR = (unsigned char) baud_prescaler;
     4de:	89 e1       	ldi	r24, 0x19	; 25
     4e0:	89 b9       	out	0x09, r24	; 9
	
	/* Enable UART receiver and transmitter */
	UCR = (( 1 << RXEN ) | ( 1 << TXEN ) | ( 1 << TXB8 ) | (1 << RXB8)); 
     4e2:	8b e1       	ldi	r24, 0x1B	; 27
     4e4:	8a b9       	out	0x0a, r24	; 10
	//uint8_t page_adc_vals[8][8];
	
	cli();	// clear enable interrupts
	
	UART_init(BAUD_PRESCALLER); /* Set the baudrate */
	lcd_init(LCD_DISP_ON); 		  /* initialize lcd, display on, cursor off */
     4e6:	8c e0       	ldi	r24, 0x0C	; 12
     4e8:	3a d2       	rcall	.+1140   	; 0x95e <lcd_init>

	greeting();		// send greeting message
     4ea:	e3 df       	rcall	.-58     	; 0x4b2 <greeting>

	DDRC = 0xFF;	// all pins of PortC as output
     4ec:	8f ef       	ldi	r24, 0xFF	; 255
     4ee:	84 bb       	out	0x14, r24	; 20

	DDRA = 0x00;	// Configure PortA as input
     4f0:	1a ba       	out	0x1a, r1	; 26
    TIMSK |= (1 << OCIE1A);
}

void adc_init()		//initialization of ADC
{
	ADCSR |= (1 << ADEN);  // Enable ADC
     4f2:	37 9a       	sbi	0x06, 7	; 6

	ADCSR |= (1 << ADPS2) | (1 << ADPS0); // Set ADC prescaler to 32 - 125KHz sample rate @ 4MHz
     4f4:	86 b1       	in	r24, 0x06	; 6
     4f6:	85 60       	ori	r24, 0x05	; 5
     4f8:	86 b9       	out	0x06, r24	; 6

	ADMUX = 0; //Binary equivalent of										  
     4fa:	17 b8       	out	0x07, r1	; 7
						
	//timer0_init();	// initialization of Timer0
	
	adc_init();		// initialization of ADC
	
	eeprom_init();	//intialization of external eeprom
     4fc:	27 d0       	rcall	.+78     	; 0x54c <eeprom_init>
	spi_init();
     4fe:	39 d0       	rcall	.+114    	; 0x572 <spi_init>

	eeprom_pointer = get_eeprom_start_pointer();
     500:	0c d0       	rcall	.+24     	; 0x51a <get_eeprom_start_pointer>
     502:	90 93 42 01 	sts	0x0142, r25
     506:	80 93 41 01 	sts	0x0141, r24
	eeprom_write_counter = 0; // set number of writings to 0
     50a:	10 92 3e 01 	sts	0x013E, r1
	// uart_transmit_adc64(page_adc_vals);

	// read_page_eeprom(*page_adc_vals, 64, EEPROM_PAGE_SIZE);
	// uart_transmit_adc64(page_adc_vals);

	lcd_preparation_for_adc();
     50e:	75 df       	rcall	.-278    	; 0x3fa <lcd_preparation_for_adc>
	timer1_init();  // initialization of Timer1
     510:	b0 dd       	rcall	.-1184   	; 0x72 <timer1_init>
	//get_adc_vals(port_adc_vals);

    sei();	// set enable interrupts
     512:	78 94       	sei
}
     514:	08 95       	ret

00000516 <main>:
uint16_t eeprom_pointer; //current pointer in eeprom
uint8_t eeprom_write_counter; //counting till 8 for reading a page

int main(void)
{	
	setup();	// Start initialization
     516:	e2 df       	rcall	.-60     	; 0x4dc <setup>
     518:	ff cf       	rjmp	.-2      	; 0x518 <main+0x2>

0000051a <get_eeprom_start_pointer>:
**	Params:	None
**	Returns: word - start location in eeprom
** -----------------------------------------------------------------------*/
word get_eeprom_start_pointer()
{
	return eeprom_start;
     51a:	20 91 45 01 	lds	r18, 0x0145
     51e:	30 91 46 01 	lds	r19, 0x0146
}
     522:	82 2f       	mov	r24, r18
     524:	93 2f       	mov	r25, r19
     526:	08 95       	ret

00000528 <get_eeprom_avail_pointer>:
**	Params:	None
**	Returns: word - Next available location in eeprom
** -----------------------------------------------------------------------*/
word get_eeprom_avail_pointer()
{
	return eeprom_avail;
     528:	20 91 3f 01 	lds	r18, 0x013F
     52c:	30 91 40 01 	lds	r19, 0x0140
}
     530:	82 2f       	mov	r24, r18
     532:	93 2f       	mov	r25, r19
     534:	08 95       	ret

00000536 <update_eeprom_pointer>:
**	Params:	word - Offset
**	Returns: None
** -----------------------------------------------------------------------*/
void update_eeprom_pointer(word offset)
{
	eeprom_avail += offset;
     536:	20 91 3f 01 	lds	r18, 0x013F
     53a:	30 91 40 01 	lds	r19, 0x0140
     53e:	28 0f       	add	r18, r24
     540:	39 1f       	adc	r19, r25
     542:	30 93 40 01 	sts	0x0140, r19
     546:	20 93 3f 01 	sts	0x013F, r18
}
     54a:	08 95       	ret

0000054c <eeprom_init>:
**	Params:	None
**	Returns: None
** -----------------------------------------------------------------------*/
void eeprom_init()
{
	eeprom_start = 0;
     54c:	10 92 46 01 	sts	0x0146, r1
     550:	10 92 45 01 	sts	0x0145, r1
	eeprom_avail = 0;
     554:	10 92 40 01 	sts	0x0140, r1
     558:	10 92 3f 01 	sts	0x013F, r1
	eeprom_end = eeprom_start + EEPROM_SIZE;
     55c:	80 91 45 01 	lds	r24, 0x0145
     560:	90 91 46 01 	lds	r25, 0x0146
     564:	80 50       	subi	r24, 0x00	; 0
     566:	90 48       	sbci	r25, 0x80	; 128
     568:	90 93 44 01 	sts	0x0144, r25
     56c:	80 93 43 01 	sts	0x0143, r24
}
     570:	08 95       	ret

00000572 <spi_init>:
**	Params:	None
**	Returns: None
** -----------------------------------------------------------------------*/
void spi_init()
{
	DDRB |= _BV(SLAVESELECT) | _BV(SPICLOCK) | _BV(DATAOUT);
     572:	87 b3       	in	r24, 0x17	; 23
     574:	80 6b       	ori	r24, 0xB0	; 176
     576:	87 bb       	out	0x17, r24	; 23
	PORTB |= _BV(SLAVESELECT);
     578:	c4 9a       	sbi	0x18, 4	; 24
  
	 // SPCR = 01010000
	 //interrupt disabled,spi enabled,msb 1st,master,clk low when idle,
	 //sample on leading edge of clk,system clock/4 rate (fastest)
	 SPCR = _BV(SPE) | _BV(MSTR);
     57a:	80 e5       	ldi	r24, 0x50	; 80
     57c:	8d b9       	out	0x0d, r24	; 13
}
     57e:	08 95       	ret

00000580 <write_enable_eeprom>:
**	Params:	None
**	Returns: None
** -----------------------------------------------------------------------*/
void write_enable_eeprom()
{
	PORTB &= ~_BV(SLAVESELECT);
     580:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     582:	86 e0       	ldi	r24, 0x06	; 6
     584:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     586:	77 9b       	sbis	0x0e, 7	; 14
     588:	fe cf       	rjmp	.-4      	; 0x586 <write_enable_eeprom+0x6>

  return SPDR;                	// return the received byte
     58a:	8f b1       	in	r24, 0x0f	; 15
void write_enable_eeprom()
{
	PORTB &= ~_BV(SLAVESELECT);

	spi_transfer(WREN); //write enable
	PORTB |= _BV(SLAVESELECT);
     58c:	c4 9a       	sbi	0x18, 4	; 24
}
     58e:	08 95       	ret

00000590 <spi_transfer>:
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     590:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     592:	77 9b       	sbis	0x0e, 7	; 14
     594:	fe cf       	rjmp	.-4      	; 0x592 <spi_transfer+0x2>

  return SPDR;                	// return the received byte
     596:	8f b1       	in	r24, 0x0f	; 15
}
     598:	08 95       	ret

0000059a <write_in_process_status>:
	}
}

int write_in_process_status(){
	// send read status comand, get status and send WIP bit
	PORTB &= ~_BV(SLAVESELECT);
     59a:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     59c:	85 e0       	ldi	r24, 0x05	; 5
     59e:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     5a0:	77 9b       	sbis	0x0e, 7	; 14
     5a2:	fe cf       	rjmp	.-4      	; 0x5a0 <write_in_process_status+0x6>

  return SPDR;                	// return the received byte
     5a4:	8f b1       	in	r24, 0x0f	; 15
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     5a6:	8f ef       	ldi	r24, 0xFF	; 255
     5a8:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     5aa:	77 9b       	sbis	0x0e, 7	; 14
     5ac:	fe cf       	rjmp	.-4      	; 0x5aa <write_in_process_status+0x10>

  return SPDR;                	// return the received byte
     5ae:	2f b1       	in	r18, 0x0f	; 15
     5b0:	30 e0       	ldi	r19, 0x00	; 0
     5b2:	22 70       	andi	r18, 0x02	; 2
     5b4:	30 70       	andi	r19, 0x00	; 0
	// send read status comand, get status and send WIP bit
	PORTB &= ~_BV(SLAVESELECT);
	spi_transfer(RDSR);
	return (spi_transfer(0xFF) & 2);
	PORTB |= _BV(SLAVESELECT);
}
     5b6:	82 2f       	mov	r24, r18
     5b8:	93 2f       	mov	r25, r19
     5ba:	08 95       	ret

000005bc <word_transfer>:

void word_transfer(word address)
{
     5bc:	df 93       	push	r29
     5be:	cf 93       	push	r28
     5c0:	00 d0       	rcall	.+0      	; 0x5c2 <word_transfer+0x6>
     5c2:	cd b7       	in	r28, 0x3d	; 61
     5c4:	de b7       	in	r29, 0x3e	; 62
     5c6:	9a 83       	std	Y+2, r25	; 0x02
     5c8:	89 83       	std	Y+1, r24	; 0x01
	byte low_byte;
	byte high_byte;
	unsigned char *the_ptr;

	the_ptr = ((unsigned char *) &address);
	low_byte = *the_ptr;
     5ca:	98 2f       	mov	r25, r24
	the_ptr++;
	high_byte = *((unsigned char *)the_ptr);
     5cc:	8a 81       	ldd	r24, Y+2	; 0x02
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     5ce:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     5d0:	77 9b       	sbis	0x0e, 7	; 14
     5d2:	fe cf       	rjmp	.-4      	; 0x5d0 <word_transfer+0x14>

  return SPDR;                	// return the received byte
     5d4:	8f b1       	in	r24, 0x0f	; 15
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     5d6:	9f b9       	out	0x0f, r25	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     5d8:	77 9b       	sbis	0x0e, 7	; 14
     5da:	fe cf       	rjmp	.-4      	; 0x5d8 <word_transfer+0x1c>

  return SPDR;                	// return the received byte
     5dc:	8f b1       	in	r24, 0x0f	; 15
	low_byte = *the_ptr;
	the_ptr++;
	high_byte = *((unsigned char *)the_ptr);
	spi_transfer(high_byte);
	spi_transfer(low_byte);
}
     5de:	0f 90       	pop	r0
     5e0:	0f 90       	pop	r0
     5e2:	cf 91       	pop	r28
     5e4:	df 91       	pop	r29
     5e6:	08 95       	ret

000005e8 <eeprom_chip_erase>:

	return true;
}

void eeprom_chip_erase()
{
     5e8:	ef 92       	push	r14
     5ea:	ff 92       	push	r15
     5ec:	0f 93       	push	r16
     5ee:	1f 93       	push	r17
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	c0 e0       	ldi	r28, 0x00	; 0
     5f6:	d0 e0       	ldi	r29, 0x00	; 0
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     5f8:	92 e0       	ldi	r25, 0x02	; 2
     5fa:	e9 2e       	mov	r14, r25
     5fc:	86 e6       	ldi	r24, 0x66	; 102
     5fe:	f8 2e       	mov	r15, r24
     600:	08 e8       	ldi	r16, 0x88	; 136
     602:	13 e1       	ldi	r17, 0x13	; 19

void eeprom_chip_erase()
{
	for (int j = 0; j < EEPROM_SIZE; j += EEPROM_PAGE_SIZE){
		//while(write_in_process_status()){};
		write_enable_eeprom();
     604:	bd df       	rcall	.-134    	; 0x580 <write_enable_eeprom>

		PORTB &= ~_BV(SLAVESELECT);
     606:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     608:	ef b8       	out	0x0f, r14	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     60a:	77 9b       	sbis	0x0e, 7	; 14
     60c:	fe cf       	rjmp	.-4      	; 0x60a <eeprom_chip_erase+0x22>

  return SPDR;                	// return the received byte
     60e:	8f b1       	in	r24, 0x0f	; 15
		//while(write_in_process_status()){};
		write_enable_eeprom();

		PORTB &= ~_BV(SLAVESELECT);
		spi_transfer(WRITE); //write instruction
		word_transfer(j); // send MSByte and then LSByte
     610:	8c 2f       	mov	r24, r28
     612:	9d 2f       	mov	r25, r29
     614:	d3 df       	rcall	.-90     	; 0x5bc <word_transfer>
     616:	80 e0       	ldi	r24, 0x00	; 0
     618:	90 e0       	ldi	r25, 0x00	; 0
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     61a:	ff b8       	out	0x0f, r15	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     61c:	77 9b       	sbis	0x0e, 7	; 14
     61e:	fe cf       	rjmp	.-4      	; 0x61c <eeprom_chip_erase+0x34>

  return SPDR;                	// return the received byte
     620:	2f b1       	in	r18, 0x0f	; 15
		write_enable_eeprom();

		PORTB &= ~_BV(SLAVESELECT);
		spi_transfer(WRITE); //write instruction
		word_transfer(j); // send MSByte and then LSByte
	  	for (int i = 0; i < EEPROM_PAGE_SIZE; i++){
     622:	01 96       	adiw	r24, 0x01	; 1
     624:	80 34       	cpi	r24, 0x40	; 64
     626:	91 05       	cpc	r25, r1
     628:	c1 f7       	brne	.-16     	; 0x61a <eeprom_chip_erase+0x32>
		    spi_transfer(0x66); //write data byte
		}
		PORTB |= _BV(SLAVESELECT);
     62a:	c4 9a       	sbi	0x18, 4	; 24
		PORTB &= ~_BV(DATAOUT);
     62c:	c5 98       	cbi	0x18, 5	; 24
     62e:	80 2f       	mov	r24, r16
     630:	91 2f       	mov	r25, r17
     632:	01 97       	sbiw	r24, 0x01	; 1
     634:	f1 f7       	brne	.-4      	; 0x632 <eeprom_chip_erase+0x4a>
	return true;
}

void eeprom_chip_erase()
{
	for (int j = 0; j < EEPROM_SIZE; j += EEPROM_PAGE_SIZE){
     636:	c0 5c       	subi	r28, 0xC0	; 192
     638:	df 4f       	sbci	r29, 0xFF	; 255
     63a:	e4 cf       	rjmp	.-56     	; 0x604 <eeprom_chip_erase+0x1c>

0000063c <eeprom_page_erase>:

  return SPDR;                	// return the received byte
}

bool eeprom_page_erase(word address)
{
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
     640:	c8 2f       	mov	r28, r24
     642:	d9 2f       	mov	r29, r25
	if (address >= EEPROM_SIZE)
     644:	97 ff       	sbrs	r25, 7
     646:	02 c0       	rjmp	.+4      	; 0x64c <eeprom_page_erase+0x10>
     648:	80 e0       	ldi	r24, 0x00	; 0
     64a:	18 c0       	rjmp	.+48     	; 0x67c <eeprom_page_erase+0x40>
		return false;

	write_enable_eeprom();
     64c:	99 df       	rcall	.-206    	; 0x580 <write_enable_eeprom>

	PORTB &= ~_BV(SLAVESELECT);
     64e:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     650:	82 e0       	ldi	r24, 0x02	; 2
     652:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     654:	77 9b       	sbis	0x0e, 7	; 14
     656:	fe cf       	rjmp	.-4      	; 0x654 <eeprom_page_erase+0x18>

  return SPDR;                	// return the received byte
     658:	8f b1       	in	r24, 0x0f	; 15

	write_enable_eeprom();

	PORTB &= ~_BV(SLAVESELECT);
	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
     65a:	8c 2f       	mov	r24, r28
     65c:	9d 2f       	mov	r25, r29
     65e:	ae df       	rcall	.-164    	; 0x5bc <word_transfer>
     660:	80 e0       	ldi	r24, 0x00	; 0
     662:	90 e0       	ldi	r25, 0x00	; 0
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     664:	26 e6       	ldi	r18, 0x66	; 102
     666:	2f b9       	out	0x0f, r18	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     668:	77 9b       	sbis	0x0e, 7	; 14
     66a:	fe cf       	rjmp	.-4      	; 0x668 <eeprom_page_erase+0x2c>

  return SPDR;                	// return the received byte
     66c:	3f b1       	in	r19, 0x0f	; 15
	write_enable_eeprom();

	PORTB &= ~_BV(SLAVESELECT);
	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
  	for (int i = 0; i < EEPROM_PAGE_SIZE; i++){
     66e:	01 96       	adiw	r24, 0x01	; 1
     670:	80 34       	cpi	r24, 0x40	; 64
     672:	91 05       	cpc	r25, r1
     674:	c1 f7       	brne	.-16     	; 0x666 <eeprom_page_erase+0x2a>
	    spi_transfer(0x66); //write data byte
	}
	PORTB |= _BV(SLAVESELECT);
     676:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~_BV(DATAOUT);
     678:	c5 98       	cbi	0x18, 5	; 24
     67a:	81 e0       	ldi	r24, 0x01	; 1

	return true;
}
     67c:	df 91       	pop	r29
     67e:	cf 91       	pop	r28
     680:	08 95       	ret

00000682 <write_page_eeprom>:
**			word - address to write data
**			word - length of data
**	Returns: bool - true on success false otherwise
** -----------------------------------------------------------------------*/
bool write_page_eeprom(word address, byte* data, word len)
{
     682:	ef 92       	push	r14
     684:	ff 92       	push	r15
     686:	0f 93       	push	r16
     688:	1f 93       	push	r17
     68a:	cf 93       	push	r28
     68c:	df 93       	push	r29
     68e:	08 2f       	mov	r16, r24
     690:	19 2f       	mov	r17, r25
     692:	c6 2f       	mov	r28, r22
     694:	d7 2f       	mov	r29, r23
     696:	e4 2e       	mov	r14, r20
     698:	f5 2e       	mov	r15, r21
	if (address >= EEPROM_SIZE || len > EEPROM_PAGE_SIZE)
     69a:	97 fd       	sbrc	r25, 7
     69c:	1f c0       	rjmp	.+62     	; 0x6dc <write_page_eeprom+0x5a>
     69e:	41 34       	cpi	r20, 0x41	; 65
     6a0:	51 05       	cpc	r21, r1
     6a2:	e0 f4       	brcc	.+56     	; 0x6dc <write_page_eeprom+0x5a>
		return false;

	write_enable_eeprom();
     6a4:	6d df       	rcall	.-294    	; 0x580 <write_enable_eeprom>

	PORTB &= ~_BV(SLAVESELECT);
     6a6:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     6a8:	82 e0       	ldi	r24, 0x02	; 2
     6aa:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     6ac:	77 9b       	sbis	0x0e, 7	; 14
     6ae:	fe cf       	rjmp	.-4      	; 0x6ac <write_page_eeprom+0x2a>

  return SPDR;                	// return the received byte
     6b0:	8f b1       	in	r24, 0x0f	; 15

	write_enable_eeprom();

	PORTB &= ~_BV(SLAVESELECT);
	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
     6b2:	80 2f       	mov	r24, r16
     6b4:	91 2f       	mov	r25, r17
     6b6:	82 df       	rcall	.-252    	; 0x5bc <word_transfer>
     6b8:	20 e0       	ldi	r18, 0x00	; 0
     6ba:	30 e0       	ldi	r19, 0x00	; 0
     6bc:	08 c0       	rjmp	.+16     	; 0x6ce <write_page_eeprom+0x4c>
  	for (int i = 0; i < len; i++){
	    spi_transfer(*(data)); //write data byte
     6be:	88 81       	ld	r24, Y
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     6c0:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     6c2:	77 9b       	sbis	0x0e, 7	; 14
     6c4:	fe cf       	rjmp	.-4      	; 0x6c2 <write_page_eeprom+0x40>

  return SPDR;                	// return the received byte
     6c6:	8f b1       	in	r24, 0x0f	; 15
	PORTB &= ~_BV(SLAVESELECT);
	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
  	for (int i = 0; i < len; i++){
	    spi_transfer(*(data)); //write data byte
	    data++;
     6c8:	21 96       	adiw	r28, 0x01	; 1
	write_enable_eeprom();

	PORTB &= ~_BV(SLAVESELECT);
	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
  	for (int i = 0; i < len; i++){
     6ca:	2f 5f       	subi	r18, 0xFF	; 255
     6cc:	3f 4f       	sbci	r19, 0xFF	; 255
     6ce:	2e 15       	cp	r18, r14
     6d0:	3f 05       	cpc	r19, r15
     6d2:	a8 f3       	brcs	.-22     	; 0x6be <write_page_eeprom+0x3c>
	    spi_transfer(*(data)); //write data byte
	    data++;
	}
	PORTB |= _BV(SLAVESELECT);
     6d4:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~_BV(DATAOUT);
     6d6:	c5 98       	cbi	0x18, 5	; 24
     6d8:	81 e0       	ldi	r24, 0x01	; 1
     6da:	01 c0       	rjmp	.+2      	; 0x6de <write_page_eeprom+0x5c>

	return true;
     6dc:	80 e0       	ldi	r24, 0x00	; 0
}
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	1f 91       	pop	r17
     6e4:	0f 91       	pop	r16
     6e6:	ff 90       	pop	r15
     6e8:	ef 90       	pop	r14
     6ea:	08 95       	ret

000006ec <write_eeprom>:
**			word - address to write data
**			word - length of data
**	Returns: bool - true on success false otherwise
** -----------------------------------------------------------------------*/
bool write_eeprom(word address, byte data)
{
     6ec:	1f 93       	push	r17
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	c8 2f       	mov	r28, r24
     6f4:	d9 2f       	mov	r29, r25
     6f6:	16 2f       	mov	r17, r22
	if (address >= EEPROM_SIZE)
     6f8:	97 ff       	sbrs	r25, 7
     6fa:	02 c0       	rjmp	.+4      	; 0x700 <write_eeprom+0x14>
     6fc:	80 e0       	ldi	r24, 0x00	; 0
     6fe:	11 c0       	rjmp	.+34     	; 0x722 <write_eeprom+0x36>
		return false;

	write_enable_eeprom();
     700:	3f df       	rcall	.-386    	; 0x580 <write_enable_eeprom>

	PORTB &= ~_BV(SLAVESELECT);
     702:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     704:	82 e0       	ldi	r24, 0x02	; 2
     706:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     708:	77 9b       	sbis	0x0e, 7	; 14
     70a:	fe cf       	rjmp	.-4      	; 0x708 <write_eeprom+0x1c>

  return SPDR;                	// return the received byte
     70c:	8f b1       	in	r24, 0x0f	; 15
	write_enable_eeprom();

	PORTB &= ~_BV(SLAVESELECT);

	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
     70e:	8c 2f       	mov	r24, r28
     710:	9d 2f       	mov	r25, r29
     712:	54 df       	rcall	.-344    	; 0x5bc <word_transfer>
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     714:	1f b9       	out	0x0f, r17	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     716:	77 9b       	sbis	0x0e, 7	; 14
     718:	fe cf       	rjmp	.-4      	; 0x716 <write_eeprom+0x2a>

  return SPDR;                	// return the received byte
     71a:	8f b1       	in	r24, 0x0f	; 15

	spi_transfer(WRITE); //write instruction
	word_transfer(address); // send MSByte and then LSByte
    spi_transfer(data); //write data byte

	PORTB |= _BV(SLAVESELECT);
     71c:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~_BV(DATAOUT);
     71e:	c5 98       	cbi	0x18, 5	; 24
     720:	81 e0       	ldi	r24, 0x01	; 1

	return true;
}
     722:	df 91       	pop	r29
     724:	cf 91       	pop	r28
     726:	1f 91       	pop	r17
     728:	08 95       	ret

0000072a <read_page_eeprom>:
**			word - address to read from
**			word - length of data to read
**	Returns: bool - true on success false otherwise
** -----------------------------------------------------------------------*/
bool read_page_eeprom(byte* pdata, word address, word len)
{
     72a:	0f 93       	push	r16
     72c:	1f 93       	push	r17
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
     732:	08 2f       	mov	r16, r24
     734:	19 2f       	mov	r17, r25
     736:	c4 2f       	mov	r28, r20
     738:	d5 2f       	mov	r29, r21
	if (address >= EEPROM_SIZE || len > EEPROM_PAGE_SIZE)
     73a:	77 fd       	sbrc	r23, 7
     73c:	22 c0       	rjmp	.+68     	; 0x782 <read_page_eeprom+0x58>
     73e:	41 34       	cpi	r20, 0x41	; 65
     740:	51 05       	cpc	r21, r1
     742:	f8 f4       	brcc	.+62     	; 0x782 <read_page_eeprom+0x58>
		return false;
	
	PORTB &= ~_BV(SLAVESELECT);
     744:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     746:	83 e0       	ldi	r24, 0x03	; 3
     748:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     74a:	77 9b       	sbis	0x0e, 7	; 14
     74c:	fe cf       	rjmp	.-4      	; 0x74a <read_page_eeprom+0x20>

  return SPDR;                	// return the received byte
     74e:	8f b1       	in	r24, 0x0f	; 15
		return false;
	
	PORTB &= ~_BV(SLAVESELECT);

	spi_transfer(READ); //transmit read opcode
	word_transfer(address); // send MSByte and then LSByte
     750:	86 2f       	mov	r24, r22
     752:	97 2f       	mov	r25, r23
     754:	33 df       	rcall	.-410    	; 0x5bc <word_transfer>
     756:	20 e0       	ldi	r18, 0x00	; 0
     758:	30 e0       	ldi	r19, 0x00	; 0
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     75a:	9f ef       	ldi	r25, 0xFF	; 255
     75c:	0b c0       	rjmp	.+22     	; 0x774 <read_page_eeprom+0x4a>
     75e:	9f b9       	out	0x0f, r25	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     760:	77 9b       	sbis	0x0e, 7	; 14
     762:	fe cf       	rjmp	.-4      	; 0x760 <read_page_eeprom+0x36>

  return SPDR;                	// return the received byte
     764:	8f b1       	in	r24, 0x0f	; 15

	spi_transfer(READ); //transmit read opcode
	word_transfer(address); // send MSByte and then LSByte

	for (int i = 0; i < len; i++)
		*pdata++ = spi_transfer(0xFF);
     766:	e0 2f       	mov	r30, r16
     768:	f1 2f       	mov	r31, r17
     76a:	81 93       	st	Z+, r24
     76c:	0e 2f       	mov	r16, r30
     76e:	1f 2f       	mov	r17, r31
	PORTB &= ~_BV(SLAVESELECT);

	spi_transfer(READ); //transmit read opcode
	word_transfer(address); // send MSByte and then LSByte

	for (int i = 0; i < len; i++)
     770:	2f 5f       	subi	r18, 0xFF	; 255
     772:	3f 4f       	sbci	r19, 0xFF	; 255
     774:	2c 17       	cp	r18, r28
     776:	3d 07       	cpc	r19, r29
     778:	90 f3       	brcs	.-28     	; 0x75e <read_page_eeprom+0x34>
		*pdata++ = spi_transfer(0xFF);


	PORTB |= _BV(SLAVESELECT);
     77a:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~_BV(DATAOUT);
     77c:	c5 98       	cbi	0x18, 5	; 24
     77e:	81 e0       	ldi	r24, 0x01	; 1
     780:	01 c0       	rjmp	.+2      	; 0x784 <read_page_eeprom+0x5a>

	return true;
     782:	80 e0       	ldi	r24, 0x00	; 0
}
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	1f 91       	pop	r17
     78a:	0f 91       	pop	r16
     78c:	08 95       	ret

0000078e <eeprom_copy>:
**			word - eeprom source address
**			word - length of chunk to copy.
**	Returns: None
** -----------------------------------------------------------------------*/
bool eeprom_copy(byte* dest, word src, word len)
{
     78e:	28 2f       	mov	r18, r24
     790:	39 2f       	mov	r19, r25
	if (src + len > EEPROM_SIZE || len > EEPROM_PAGE_SIZE)
     792:	84 2f       	mov	r24, r20
     794:	95 2f       	mov	r25, r21
     796:	86 0f       	add	r24, r22
     798:	97 1f       	adc	r25, r23
     79a:	81 50       	subi	r24, 0x01	; 1
     79c:	90 48       	sbci	r25, 0x80	; 128
     79e:	40 f4       	brcc	.+16     	; 0x7b0 <eeprom_copy+0x22>
     7a0:	41 34       	cpi	r20, 0x41	; 65
     7a2:	51 05       	cpc	r21, r1
     7a4:	28 f4       	brcc	.+10     	; 0x7b0 <eeprom_copy+0x22>
		return false;

	read_page_eeprom(dest, src, len);
     7a6:	82 2f       	mov	r24, r18
     7a8:	93 2f       	mov	r25, r19
     7aa:	bf df       	rcall	.-130    	; 0x72a <read_page_eeprom>
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	08 95       	ret

	return true;
     7b0:	80 e0       	ldi	r24, 0x00	; 0
}
     7b2:	08 95       	ret

000007b4 <read_eeprom>:
**
**	Params:	word - address to read from
**	Returns: byte - data
** -----------------------------------------------------------------------*/
byte read_eeprom(word address)
{
     7b4:	28 2f       	mov	r18, r24
     7b6:	39 2f       	mov	r19, r25
	int data;

	if (address >= EEPROM_SIZE)
     7b8:	97 ff       	sbrs	r25, 7
     7ba:	02 c0       	rjmp	.+4      	; 0x7c0 <read_eeprom+0xc>
     7bc:	80 e0       	ldi	r24, 0x00	; 0
     7be:	08 95       	ret
		return null;

	PORTB &= ~_BV(SLAVESELECT);
     7c0:	c4 98       	cbi	0x18, 4	; 24
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     7c2:	83 e0       	ldi	r24, 0x03	; 3
     7c4:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     7c6:	77 9b       	sbis	0x0e, 7	; 14
     7c8:	fe cf       	rjmp	.-4      	; 0x7c6 <read_eeprom+0x12>

  return SPDR;                	// return the received byte
     7ca:	8f b1       	in	r24, 0x0f	; 15
		return null;

	PORTB &= ~_BV(SLAVESELECT);

	spi_transfer(READ); //transmit read opcode
	word_transfer(address); // send MSByte and then LSByte
     7cc:	82 2f       	mov	r24, r18
     7ce:	93 2f       	mov	r25, r19
     7d0:	f5 de       	rcall	.-534    	; 0x5bc <word_transfer>
**	Params:	uint8_t	byte to send
**	Returns: None
** -----------------------------------------------------------------------*/
byte spi_transfer(byte data)
{
  SPDR = data;
     7d2:	8f ef       	ldi	r24, 0xFF	; 255
     7d4:	8f b9       	out	0x0f, r24	; 15
  while (!(SPSR & (1<<SPIF)));	// Wait the end of the transmission
     7d6:	77 9b       	sbis	0x0e, 7	; 14
     7d8:	fe cf       	rjmp	.-4      	; 0x7d6 <read_eeprom+0x22>

  return SPDR;                	// return the received byte
     7da:	8f b1       	in	r24, 0x0f	; 15

	spi_transfer(READ); //transmit read opcode
	word_transfer(address); // send MSByte and then LSByte
	data = spi_transfer(0xFF); //get data byte

	PORTB |= _BV(SLAVESELECT);
     7dc:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~_BV(DATAOUT);
     7de:	c5 98       	cbi	0x18, 5	; 24

	return data;
}
     7e0:	08 95       	ret

000007e2 <lcd_write>:
static void lcd_write(uint8_t data,uint8_t rs) 
{
    unsigned char dataBits ;


    if (rs) {   /* write data        (RS=1, RW=0) */
     7e2:	66 23       	and	r22, r22
     7e4:	11 f0       	breq	.+4      	; 0x7ea <lcd_write+0x8>
       lcd_rs_high();
     7e6:	c0 9a       	sbi	0x18, 0	; 24
     7e8:	01 c0       	rjmp	.+2      	; 0x7ec <lcd_write+0xa>
    } else {    /* write instruction (RS=0, RW=0) */
       lcd_rs_low();
     7ea:	c0 98       	cbi	0x18, 0	; 24
    }
    lcd_rw_low();
     7ec:	c1 98       	cbi	0x18, 1	; 24
        LCD_DATA0_PORT = dataBits | 0x0F;
    }
    else
    {
        /* configure data pins as output */
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
     7ee:	8c 9a       	sbi	0x11, 4	; 17
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
     7f0:	8d 9a       	sbi	0x11, 5	; 17
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
     7f2:	8e 9a       	sbi	0x11, 6	; 17
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
     7f4:	8f 9a       	sbi	0x11, 7	; 17
        
        /* output high nibble first */
        LCD_DATA3_PORT &= ~_BV(LCD_DATA3_PIN);
     7f6:	97 98       	cbi	0x12, 7	; 18
        LCD_DATA2_PORT &= ~_BV(LCD_DATA2_PIN);
     7f8:	96 98       	cbi	0x12, 6	; 18
        LCD_DATA1_PORT &= ~_BV(LCD_DATA1_PIN);
     7fa:	95 98       	cbi	0x12, 5	; 18
        LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);
     7fc:	94 98       	cbi	0x12, 4	; 18
    	if(data & 0x80) LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
     7fe:	87 fd       	sbrc	r24, 7
     800:	97 9a       	sbi	0x12, 7	; 18
    	if(data & 0x40) LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
     802:	86 fd       	sbrc	r24, 6
     804:	96 9a       	sbi	0x12, 6	; 18
    	if(data & 0x20) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
     806:	85 fd       	sbrc	r24, 5
     808:	95 9a       	sbi	0x12, 5	; 18
    	if(data & 0x10) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);   
     80a:	84 fd       	sbrc	r24, 4
     80c:	94 9a       	sbi	0x12, 4	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
     80e:	c2 9a       	sbi	0x18, 2	; 24
    lcd_e_delay();
     810:	00 c0       	rjmp	.+0      	; 0x812 <lcd_write+0x30>
    lcd_e_low();
     812:	c2 98       	cbi	0x18, 2	; 24
    	if(data & 0x20) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
    	if(data & 0x10) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);   
        lcd_e_toggle();
        
        /* output low nibble */
        LCD_DATA3_PORT &= ~_BV(LCD_DATA3_PIN);
     814:	97 98       	cbi	0x12, 7	; 18
        LCD_DATA2_PORT &= ~_BV(LCD_DATA2_PIN);
     816:	96 98       	cbi	0x12, 6	; 18
        LCD_DATA1_PORT &= ~_BV(LCD_DATA1_PIN);
     818:	95 98       	cbi	0x12, 5	; 18
        LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);
     81a:	94 98       	cbi	0x12, 4	; 18
    	if(data & 0x08) LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
     81c:	83 fd       	sbrc	r24, 3
     81e:	97 9a       	sbi	0x12, 7	; 18
    	if(data & 0x04) LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
     820:	82 fd       	sbrc	r24, 2
     822:	96 9a       	sbi	0x12, 6	; 18
    	if(data & 0x02) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
     824:	81 fd       	sbrc	r24, 1
     826:	95 9a       	sbi	0x12, 5	; 18
    	if(data & 0x01) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
     828:	80 fd       	sbrc	r24, 0
     82a:	94 9a       	sbi	0x12, 4	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
     82c:	c2 9a       	sbi	0x18, 2	; 24
    lcd_e_delay();
     82e:	00 c0       	rjmp	.+0      	; 0x830 <lcd_write+0x4e>
    lcd_e_low();
     830:	c2 98       	cbi	0x18, 2	; 24
    	if(data & 0x02) LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
    	if(data & 0x01) LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
        lcd_e_toggle();        
        
        /* all data pins high (inactive) */
        LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);
     832:	94 9a       	sbi	0x12, 4	; 18
        LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);
     834:	95 9a       	sbi	0x12, 5	; 18
        LCD_DATA2_PORT |= _BV(LCD_DATA2_PIN);
     836:	96 9a       	sbi	0x12, 6	; 18
        LCD_DATA3_PORT |= _BV(LCD_DATA3_PIN);
     838:	97 9a       	sbi	0x12, 7	; 18
    }
}
     83a:	08 95       	ret

0000083c <lcd_read>:
static uint8_t lcd_read(uint8_t rs) 
{
    uint8_t data;
    
    
    if (rs)
     83c:	88 23       	and	r24, r24
     83e:	11 f0       	breq	.+4      	; 0x844 <lcd_read+0x8>
        lcd_rs_high();                       /* RS=1: read data      */
     840:	c0 9a       	sbi	0x18, 0	; 24
     842:	01 c0       	rjmp	.+2      	; 0x846 <lcd_read+0xa>
    else
        lcd_rs_low();                        /* RS=0: read busy flag */
     844:	c0 98       	cbi	0x18, 0	; 24
    lcd_rw_high();                           /* RW=1  read mode      */
     846:	c1 9a       	sbi	0x18, 1	; 24
        lcd_e_low();
    }
    else
    {
        /* configure data pins as input */
        DDR(LCD_DATA0_PORT) &= ~_BV(LCD_DATA0_PIN);
     848:	8c 98       	cbi	0x11, 4	; 17
        DDR(LCD_DATA1_PORT) &= ~_BV(LCD_DATA1_PIN);
     84a:	8d 98       	cbi	0x11, 5	; 17
        DDR(LCD_DATA2_PORT) &= ~_BV(LCD_DATA2_PIN);
     84c:	8e 98       	cbi	0x11, 6	; 17
        DDR(LCD_DATA3_PORT) &= ~_BV(LCD_DATA3_PIN);
     84e:	8f 98       	cbi	0x11, 7	; 17
                
        /* read high nibble first */
        lcd_e_high();
     850:	c2 9a       	sbi	0x18, 2	; 24
        lcd_e_delay();        
     852:	00 c0       	rjmp	.+0      	; 0x854 <lcd_read+0x18>
        data = 0;
        if ( PIN(LCD_DATA0_PORT) & _BV(LCD_DATA0_PIN) ) data |= 0x10;
     854:	84 9b       	sbis	0x10, 4	; 16
     856:	02 c0       	rjmp	.+4      	; 0x85c <lcd_read+0x20>
     858:	80 e1       	ldi	r24, 0x10	; 16
     85a:	01 c0       	rjmp	.+2      	; 0x85e <lcd_read+0x22>
     85c:	80 e0       	ldi	r24, 0x00	; 0
        if ( PIN(LCD_DATA1_PORT) & _BV(LCD_DATA1_PIN) ) data |= 0x20;
     85e:	85 99       	sbic	0x10, 5	; 16
     860:	80 62       	ori	r24, 0x20	; 32
        if ( PIN(LCD_DATA2_PORT) & _BV(LCD_DATA2_PIN) ) data |= 0x40;
     862:	86 99       	sbic	0x10, 6	; 16
     864:	80 64       	ori	r24, 0x40	; 64
        if ( PIN(LCD_DATA3_PORT) & _BV(LCD_DATA3_PIN) ) data |= 0x80;
     866:	87 99       	sbic	0x10, 7	; 16
     868:	80 68       	ori	r24, 0x80	; 128
        lcd_e_low();
     86a:	c2 98       	cbi	0x18, 2	; 24

        lcd_e_delay();                       /* Enable 500ns low       */
     86c:	00 c0       	rjmp	.+0      	; 0x86e <lcd_read+0x32>
    
        /* read low nibble */    
        lcd_e_high();
     86e:	c2 9a       	sbi	0x18, 2	; 24
        lcd_e_delay();
     870:	00 c0       	rjmp	.+0      	; 0x872 <lcd_read+0x36>
        if ( PIN(LCD_DATA0_PORT) & _BV(LCD_DATA0_PIN) ) data |= 0x01;
     872:	84 99       	sbic	0x10, 4	; 16
     874:	81 60       	ori	r24, 0x01	; 1
        if ( PIN(LCD_DATA1_PORT) & _BV(LCD_DATA1_PIN) ) data |= 0x02;
     876:	85 99       	sbic	0x10, 5	; 16
     878:	82 60       	ori	r24, 0x02	; 2
        if ( PIN(LCD_DATA2_PORT) & _BV(LCD_DATA2_PIN) ) data |= 0x04;
     87a:	86 99       	sbic	0x10, 6	; 16
     87c:	84 60       	ori	r24, 0x04	; 4
        if ( PIN(LCD_DATA3_PORT) & _BV(LCD_DATA3_PIN) ) data |= 0x08;        
     87e:	87 99       	sbic	0x10, 7	; 16
     880:	88 60       	ori	r24, 0x08	; 8
        lcd_e_low();
     882:	c2 98       	cbi	0x18, 2	; 24
    }
    return data;
}
     884:	08 95       	ret

00000886 <lcd_waitbusy>:

{
    register uint8_t c;
    
    /* wait until busy flag is cleared */
    while ( (c=lcd_read(0)) & (1<<LCD_BUSY)) {}
     886:	80 e0       	ldi	r24, 0x00	; 0
     888:	d9 df       	rcall	.-78     	; 0x83c <lcd_read>
     88a:	87 fd       	sbrc	r24, 7
     88c:	fc cf       	rjmp	.-8      	; 0x886 <lcd_waitbusy>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
     88e:	82 e0       	ldi	r24, 0x02	; 2
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	01 97       	sbiw	r24, 0x01	; 1
     894:	f1 f7       	brne	.-4      	; 0x892 <lcd_waitbusy+0xc>
    
    /* the address counter is updated 4us after the busy flag is cleared */
    delay(2);

    /* now read the address counter */
    return (lcd_read(0));  // return address counter
     896:	80 e0       	ldi	r24, 0x00	; 0
     898:	d1 df       	rcall	.-94     	; 0x83c <lcd_read>
    
}/* lcd_waitbusy */
     89a:	08 95       	ret

0000089c <lcd_command>:
Send LCD controller instruction command
Input:   instruction to send to LCD controller, see HD44780 data sheet
Returns: none
*************************************************************************/
void lcd_command(uint8_t cmd)
{
     89c:	1f 93       	push	r17
     89e:	18 2f       	mov	r17, r24
    lcd_waitbusy();
     8a0:	f2 df       	rcall	.-28     	; 0x886 <lcd_waitbusy>
    lcd_write(cmd,0);
     8a2:	81 2f       	mov	r24, r17
     8a4:	60 e0       	ldi	r22, 0x00	; 0
     8a6:	9d df       	rcall	.-198    	; 0x7e2 <lcd_write>
}
     8a8:	1f 91       	pop	r17
     8aa:	08 95       	ret

000008ac <lcd_data>:
Send data byte to LCD controller 
Input:   data to send to LCD controller, see HD44780 data sheet
Returns: none
*************************************************************************/
void lcd_data(uint8_t data)
{
     8ac:	1f 93       	push	r17
     8ae:	18 2f       	mov	r17, r24
    lcd_waitbusy();
     8b0:	ea df       	rcall	.-44     	; 0x886 <lcd_waitbusy>
    lcd_write(data,1);
     8b2:	81 2f       	mov	r24, r17
     8b4:	61 e0       	ldi	r22, 0x01	; 1
     8b6:	95 df       	rcall	.-214    	; 0x7e2 <lcd_write>
}
     8b8:	1f 91       	pop	r17
     8ba:	08 95       	ret

000008bc <lcd_gotoxy>:
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
    else
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE2+x);
#endif
#if LCD_LINES==4
    if ( y==0 )
     8bc:	66 23       	and	r22, r22
     8be:	11 f4       	brne	.+4      	; 0x8c4 <lcd_gotoxy+0x8>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE1+x);
     8c0:	80 58       	subi	r24, 0x80	; 128
     8c2:	09 c0       	rjmp	.+18     	; 0x8d6 <lcd_gotoxy+0x1a>
    else if ( y==1)
     8c4:	61 30       	cpi	r22, 0x01	; 1
     8c6:	11 f4       	brne	.+4      	; 0x8cc <lcd_gotoxy+0x10>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE2+x);
     8c8:	80 54       	subi	r24, 0x40	; 64
     8ca:	05 c0       	rjmp	.+10     	; 0x8d6 <lcd_gotoxy+0x1a>
    else if ( y==2)
     8cc:	62 30       	cpi	r22, 0x02	; 2
     8ce:	11 f4       	brne	.+4      	; 0x8d4 <lcd_gotoxy+0x18>
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE3+x);
     8d0:	80 57       	subi	r24, 0x70	; 112
     8d2:	01 c0       	rjmp	.+2      	; 0x8d6 <lcd_gotoxy+0x1a>
    else /* y==3 */
        lcd_command((1<<LCD_DDRAM)+LCD_START_LINE4+x);
     8d4:	80 53       	subi	r24, 0x30	; 48
     8d6:	e2 df       	rcall	.-60     	; 0x89c <lcd_command>
     8d8:	08 95       	ret

000008da <lcd_getxy>:

/*************************************************************************
*************************************************************************/
int lcd_getxy(void)
{
    return lcd_waitbusy();
     8da:	d5 df       	rcall	.-86     	; 0x886 <lcd_waitbusy>
}
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	08 95       	ret

000008e0 <lcd_clrscr>:
/*************************************************************************
Clear display and set cursor to home position
*************************************************************************/
void lcd_clrscr(void)
{
    lcd_command(1<<LCD_CLR);
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	dc df       	rcall	.-72     	; 0x89c <lcd_command>
}
     8e4:	08 95       	ret

000008e6 <lcd_home>:
/*************************************************************************
Set cursor to home position
*************************************************************************/
void lcd_home(void)
{
    lcd_command(1<<LCD_HOME);
     8e6:	82 e0       	ldi	r24, 0x02	; 2
     8e8:	d9 df       	rcall	.-78     	; 0x89c <lcd_command>
}
     8ea:	08 95       	ret

000008ec <lcd_putc>:
Display character at current cursor position 
Input:    character to be displayed                                       
Returns:  none
*************************************************************************/
void lcd_putc(char c)
{
     8ec:	1f 93       	push	r17
     8ee:	18 2f       	mov	r17, r24
    uint8_t pos;


    pos = lcd_waitbusy();   // read busy-flag and address counter
     8f0:	ca df       	rcall	.-108    	; 0x886 <lcd_waitbusy>
     8f2:	98 2f       	mov	r25, r24
    if (c=='\n')
     8f4:	1a 30       	cpi	r17, 0x0A	; 10
     8f6:	91 f4       	brne	.+36     	; 0x91c <lcd_putc+0x30>
    else if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE4) )
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
#else
    if ( pos < LCD_START_LINE3 )
     8f8:	80 31       	cpi	r24, 0x10	; 16
     8fa:	10 f4       	brcc	.+4      	; 0x900 <lcd_putc+0x14>
     8fc:	80 e4       	ldi	r24, 0x40	; 64
     8fe:	0b c0       	rjmp	.+22     	; 0x916 <lcd_putc+0x2a>
        addressCounter = LCD_START_LINE2;
    else if ( (pos >= LCD_START_LINE2) && (pos < LCD_START_LINE4) )
     900:	80 54       	subi	r24, 0x40	; 64
     902:	80 31       	cpi	r24, 0x10	; 16
     904:	10 f4       	brcc	.+4      	; 0x90a <lcd_putc+0x1e>
     906:	80 e1       	ldi	r24, 0x10	; 16
     908:	06 c0       	rjmp	.+12     	; 0x916 <lcd_putc+0x2a>
        addressCounter = LCD_START_LINE3;
    else if ( (pos >= LCD_START_LINE3) && (pos < LCD_START_LINE2) )
     90a:	90 51       	subi	r25, 0x10	; 16
     90c:	90 33       	cpi	r25, 0x30	; 48
     90e:	10 f0       	brcs	.+4      	; 0x914 <lcd_putc+0x28>
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	01 c0       	rjmp	.+2      	; 0x916 <lcd_putc+0x2a>
     914:	80 e5       	ldi	r24, 0x50	; 80
        addressCounter = LCD_START_LINE4;
    else 
        addressCounter = LCD_START_LINE1;
#endif
#endif
    lcd_command((1<<LCD_DDRAM)+addressCounter);
     916:	80 58       	subi	r24, 0x80	; 128
     918:	c1 df       	rcall	.-126    	; 0x89c <lcd_command>
     91a:	03 c0       	rjmp	.+6      	; 0x922 <lcd_putc+0x36>
            lcd_write((1<<LCD_DDRAM)+LCD_START_LINE1,0);
        }
#endif
        lcd_waitbusy();
#endif
        lcd_write(c, 1);
     91c:	81 2f       	mov	r24, r17
     91e:	61 e0       	ldi	r22, 0x01	; 1
     920:	60 df       	rcall	.-320    	; 0x7e2 <lcd_write>
    }

}/* lcd_putc */
     922:	1f 91       	pop	r17
     924:	08 95       	ret

00000926 <lcd_puts>:
Input:    string to be displayed
Returns:  none
*************************************************************************/
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	c8 2f       	mov	r28, r24
     92c:	d9 2f       	mov	r29, r25
     92e:	01 c0       	rjmp	.+2      	; 0x932 <lcd_puts+0xc>
    register char c;

    while ( (c = *s++) ) {
        lcd_putc(c);
     930:	dd df       	rcall	.-70     	; 0x8ec <lcd_putc>
void lcd_puts(const char *s)
/* print string on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = *s++) ) {
     932:	89 91       	ld	r24, Y+
     934:	88 23       	and	r24, r24
     936:	e1 f7       	brne	.-8      	; 0x930 <lcd_puts+0xa>
        lcd_putc(c);
    }

}/* lcd_puts */
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	08 95       	ret

0000093e <lcd_puts_p>:
Input:     string from program memory be be displayed                                        
Returns:   none
*************************************************************************/
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	c8 2f       	mov	r28, r24
     944:	d9 2f       	mov	r29, r25
     946:	01 c0       	rjmp	.+2      	; 0x94a <lcd_puts_p+0xc>
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
     948:	d1 df       	rcall	.-94     	; 0x8ec <lcd_putc>
     94a:	ec 2f       	mov	r30, r28
     94c:	fd 2f       	mov	r31, r29
void lcd_puts_p(const char *progmem_s)
/* print string from program memory on lcd (no auto linefeed) */
{
    register char c;

    while ( (c = pgm_read_byte(progmem_s++)) ) {
     94e:	21 96       	adiw	r28, 0x01	; 1
     950:	c8 95       	lpm
     952:	80 2d       	mov	r24, r0
     954:	88 23       	and	r24, r24
     956:	c1 f7       	brne	.-16     	; 0x948 <lcd_puts_p+0xa>
        lcd_putc(c);
    }

}/* lcd_puts_p */
     958:	df 91       	pop	r29
     95a:	cf 91       	pop	r28
     95c:	08 95       	ret

0000095e <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
     95e:	1f 93       	push	r17
     960:	18 2f       	mov	r17, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
     962:	b8 9a       	sbi	0x17, 0	; 23
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
     964:	b9 9a       	sbi	0x17, 1	; 23
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
     966:	ba 9a       	sbi	0x17, 2	; 23
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
     968:	8c 9a       	sbi	0x11, 4	; 17
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
     96a:	8d 9a       	sbi	0x11, 5	; 17
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
     96c:	8e 9a       	sbi	0x11, 6	; 17
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
     96e:	8f 9a       	sbi	0x11, 7	; 17
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
     970:	80 e8       	ldi	r24, 0x80	; 128
     972:	9e e3       	ldi	r25, 0x3E	; 62
     974:	01 97       	sbiw	r24, 0x01	; 1
     976:	f1 f7       	brne	.-4      	; 0x974 <lcd_init+0x16>
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(16000);        /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
     978:	95 9a       	sbi	0x12, 5	; 18
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
     97a:	94 9a       	sbi	0x12, 4	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
     97c:	c2 9a       	sbi	0x18, 2	; 24
    lcd_e_delay();
     97e:	00 c0       	rjmp	.+0      	; 0x980 <lcd_init+0x22>
    lcd_e_low();
     980:	c2 98       	cbi	0x18, 2	; 24
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
     982:	80 e8       	ldi	r24, 0x80	; 128
     984:	93 e1       	ldi	r25, 0x13	; 19
     986:	01 97       	sbiw	r24, 0x01	; 1
     988:	f1 f7       	brne	.-4      	; 0x986 <lcd_init+0x28>

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
     98a:	c2 9a       	sbi	0x18, 2	; 24
    lcd_e_delay();
     98c:	00 c0       	rjmp	.+0      	; 0x98e <lcd_init+0x30>
    lcd_e_low();
     98e:	c2 98       	cbi	0x18, 2	; 24
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
     990:	80 e4       	ldi	r24, 0x40	; 64
     992:	90 e0       	ldi	r25, 0x00	; 0
     994:	e8 2f       	mov	r30, r24
     996:	f9 2f       	mov	r31, r25
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	f1 f7       	brne	.-4      	; 0x998 <lcd_init+0x3a>

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
     99c:	c2 9a       	sbi	0x18, 2	; 24
    lcd_e_delay();
     99e:	00 c0       	rjmp	.+0      	; 0x9a0 <lcd_init+0x42>
    lcd_e_low();
     9a0:	c2 98       	cbi	0x18, 2	; 24
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
     9a2:	e8 2f       	mov	r30, r24
     9a4:	f9 2f       	mov	r31, r25
     9a6:	31 97       	sbiw	r30, 0x01	; 1
     9a8:	f1 f7       	brne	.-4      	; 0x9a6 <lcd_init+0x48>
    /* repeat last command a third time */
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
     9aa:	94 98       	cbi	0x12, 4	; 18

#if LCD_IO_MODE
/* toggle Enable Pin to initiate write */
static void toggle_e(void)
{
    lcd_e_high();
     9ac:	c2 9a       	sbi	0x18, 2	; 24
    lcd_e_delay();
     9ae:	00 c0       	rjmp	.+0      	; 0x9b0 <lcd_init+0x52>
    lcd_e_low();
     9b0:	c2 98       	cbi	0x18, 2	; 24
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
     9b2:	01 97       	sbiw	r24, 0x01	; 1
     9b4:	f1 f7       	brne	.-4      	; 0x9b2 <lcd_init+0x54>
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
     9b6:	88 e2       	ldi	r24, 0x28	; 40
     9b8:	71 df       	rcall	.-286    	; 0x89c <lcd_command>
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
     9ba:	88 e0       	ldi	r24, 0x08	; 8
     9bc:	6f df       	rcall	.-290    	; 0x89c <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
     9be:	90 df       	rcall	.-224    	; 0x8e0 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
     9c0:	86 e0       	ldi	r24, 0x06	; 6
     9c2:	6c df       	rcall	.-296    	; 0x89c <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
     9c4:	81 2f       	mov	r24, r17
     9c6:	6a df       	rcall	.-300    	; 0x89c <lcd_command>

}/* lcd_init */
     9c8:	1f 91       	pop	r17
     9ca:	08 95       	ret

000009cc <__mulhi3>:
     9cc:	55 27       	eor	r21, r21
     9ce:	00 24       	eor	r0, r0

000009d0 <__mulhi3_loop>:
     9d0:	80 ff       	sbrs	r24, 0
     9d2:	02 c0       	rjmp	.+4      	; 0x9d8 <__mulhi3_skip1>
     9d4:	06 0e       	add	r0, r22
     9d6:	57 1f       	adc	r21, r23

000009d8 <__mulhi3_skip1>:
     9d8:	66 0f       	add	r22, r22
     9da:	77 1f       	adc	r23, r23
     9dc:	61 15       	cp	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	21 f0       	breq	.+8      	; 0x9ea <__mulhi3_exit>
     9e2:	96 95       	lsr	r25
     9e4:	87 95       	ror	r24
     9e6:	00 97       	sbiw	r24, 0x00	; 0
     9e8:	99 f7       	brne	.-26     	; 0x9d0 <__mulhi3_loop>

000009ea <__mulhi3_exit>:
     9ea:	95 2f       	mov	r25, r21
     9ec:	80 2d       	mov	r24, r0
     9ee:	08 95       	ret

000009f0 <__udivmodhi4>:
     9f0:	aa 1b       	sub	r26, r26
     9f2:	bb 1b       	sub	r27, r27
     9f4:	51 e1       	ldi	r21, 0x11	; 17
     9f6:	07 c0       	rjmp	.+14     	; 0xa06 <__udivmodhi4_ep>

000009f8 <__udivmodhi4_loop>:
     9f8:	aa 1f       	adc	r26, r26
     9fa:	bb 1f       	adc	r27, r27
     9fc:	a6 17       	cp	r26, r22
     9fe:	b7 07       	cpc	r27, r23
     a00:	10 f0       	brcs	.+4      	; 0xa06 <__udivmodhi4_ep>
     a02:	a6 1b       	sub	r26, r22
     a04:	b7 0b       	sbc	r27, r23

00000a06 <__udivmodhi4_ep>:
     a06:	88 1f       	adc	r24, r24
     a08:	99 1f       	adc	r25, r25
     a0a:	5a 95       	dec	r21
     a0c:	a9 f7       	brne	.-22     	; 0x9f8 <__udivmodhi4_loop>
     a0e:	80 95       	com	r24
     a10:	90 95       	com	r25
     a12:	68 2f       	mov	r22, r24
     a14:	79 2f       	mov	r23, r25
     a16:	8a 2f       	mov	r24, r26
     a18:	9b 2f       	mov	r25, r27
     a1a:	08 95       	ret

00000a1c <sprintf>:
     a1c:	ae e0       	ldi	r26, 0x0E	; 14
     a1e:	b0 e0       	ldi	r27, 0x00	; 0
     a20:	e3 e1       	ldi	r30, 0x13	; 19
     a22:	f5 e0       	ldi	r31, 0x05	; 5
     a24:	e1 c2       	rjmp	.+1474   	; 0xfe8 <__prologue_saves__+0x1c>
     a26:	0d 89       	ldd	r16, Y+21	; 0x15
     a28:	1e 89       	ldd	r17, Y+22	; 0x16
     a2a:	86 e0       	ldi	r24, 0x06	; 6
     a2c:	8c 83       	std	Y+4, r24	; 0x04
     a2e:	1a 83       	std	Y+2, r17	; 0x02
     a30:	09 83       	std	Y+1, r16	; 0x01
     a32:	8f ef       	ldi	r24, 0xFF	; 255
     a34:	9f e7       	ldi	r25, 0x7F	; 127
     a36:	9e 83       	std	Y+6, r25	; 0x06
     a38:	8d 83       	std	Y+5, r24	; 0x05
     a3a:	2c 2f       	mov	r18, r28
     a3c:	3d 2f       	mov	r19, r29
     a3e:	27 5e       	subi	r18, 0xE7	; 231
     a40:	3f 4f       	sbci	r19, 0xFF	; 255
     a42:	8c 2f       	mov	r24, r28
     a44:	9d 2f       	mov	r25, r29
     a46:	01 96       	adiw	r24, 0x01	; 1
     a48:	6f 89       	ldd	r22, Y+23	; 0x17
     a4a:	78 8d       	ldd	r23, Y+24	; 0x18
     a4c:	42 2f       	mov	r20, r18
     a4e:	53 2f       	mov	r21, r19
     a50:	0a d0       	rcall	.+20     	; 0xa66 <vfprintf>
     a52:	2f 81       	ldd	r18, Y+7	; 0x07
     a54:	38 85       	ldd	r19, Y+8	; 0x08
     a56:	02 0f       	add	r16, r18
     a58:	13 1f       	adc	r17, r19
     a5a:	e0 2f       	mov	r30, r16
     a5c:	f1 2f       	mov	r31, r17
     a5e:	10 82       	st	Z, r1
     a60:	2e 96       	adiw	r28, 0x0e	; 14
     a62:	e4 e0       	ldi	r30, 0x04	; 4
     a64:	dd c2       	rjmp	.+1466   	; 0x1020 <__epilogue_restores__+0x1c>

00000a66 <vfprintf>:
     a66:	ab e0       	ldi	r26, 0x0B	; 11
     a68:	b0 e0       	ldi	r27, 0x00	; 0
     a6a:	e8 e3       	ldi	r30, 0x38	; 56
     a6c:	f5 e0       	ldi	r31, 0x05	; 5
     a6e:	ae c2       	rjmp	.+1372   	; 0xfcc <__prologue_saves__>
     a70:	88 2e       	mov	r8, r24
     a72:	99 2e       	mov	r9, r25
     a74:	46 2e       	mov	r4, r22
     a76:	57 2e       	mov	r5, r23
     a78:	a4 2e       	mov	r10, r20
     a7a:	b5 2e       	mov	r11, r21
     a7c:	e8 2f       	mov	r30, r24
     a7e:	f9 2f       	mov	r31, r25
     a80:	17 82       	std	Z+7, r1	; 0x07
     a82:	16 82       	std	Z+6, r1	; 0x06
     a84:	83 81       	ldd	r24, Z+3	; 0x03
     a86:	81 fd       	sbrc	r24, 1
     a88:	03 c0       	rjmp	.+6      	; 0xa90 <vfprintf+0x2a>
     a8a:	6f ef       	ldi	r22, 0xFF	; 255
     a8c:	7f ef       	ldi	r23, 0xFF	; 255
     a8e:	ed c1       	rjmp	.+986    	; 0xe6a <vfprintf+0x404>
     a90:	2c 2e       	mov	r2, r28
     a92:	3d 2e       	mov	r3, r29
     a94:	08 94       	sec
     a96:	21 1c       	adc	r2, r1
     a98:	31 1c       	adc	r3, r1
     a9a:	9f e3       	ldi	r25, 0x3F	; 63
     a9c:	69 2e       	mov	r6, r25
     a9e:	e8 2d       	mov	r30, r8
     aa0:	f9 2d       	mov	r31, r9
     aa2:	33 81       	ldd	r19, Z+3	; 0x03
     aa4:	e4 2d       	mov	r30, r4
     aa6:	f5 2d       	mov	r31, r5
     aa8:	33 fd       	sbrc	r19, 3
     aaa:	c8 95       	lpm
     aac:	33 ff       	sbrs	r19, 3
     aae:	00 80       	ld	r0, Z
     ab0:	31 96       	adiw	r30, 0x01	; 1
     ab2:	80 2d       	mov	r24, r0
     ab4:	4e 2e       	mov	r4, r30
     ab6:	5f 2e       	mov	r5, r31
     ab8:	88 23       	and	r24, r24
     aba:	09 f4       	brne	.+2      	; 0xabe <vfprintf+0x58>
     abc:	d2 c1       	rjmp	.+932    	; 0xe62 <vfprintf+0x3fc>
     abe:	85 32       	cpi	r24, 0x25	; 37
     ac0:	51 f4       	brne	.+20     	; 0xad6 <vfprintf+0x70>
     ac2:	33 fd       	sbrc	r19, 3
     ac4:	c8 95       	lpm
     ac6:	33 ff       	sbrs	r19, 3
     ac8:	00 80       	ld	r0, Z
     aca:	31 96       	adiw	r30, 0x01	; 1
     acc:	80 2d       	mov	r24, r0
     ace:	4e 2e       	mov	r4, r30
     ad0:	5f 2e       	mov	r5, r31
     ad2:	85 32       	cpi	r24, 0x25	; 37
     ad4:	29 f4       	brne	.+10     	; 0xae0 <vfprintf+0x7a>
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	68 2d       	mov	r22, r8
     ada:	79 2d       	mov	r23, r9
     adc:	e4 d1       	rcall	.+968    	; 0xea6 <fputc>
     ade:	df cf       	rjmp	.-66     	; 0xa9e <vfprintf+0x38>
     ae0:	98 2f       	mov	r25, r24
     ae2:	ff 24       	eor	r15, r15
     ae4:	ee 24       	eor	r14, r14
     ae6:	77 24       	eor	r7, r7
     ae8:	ff e1       	ldi	r31, 0x1F	; 31
     aea:	ff 15       	cp	r31, r15
     aec:	d0 f0       	brcs	.+52     	; 0xb22 <vfprintf+0xbc>
     aee:	9b 32       	cpi	r25, 0x2B	; 43
     af0:	69 f0       	breq	.+26     	; 0xb0c <vfprintf+0xa6>
     af2:	9c 32       	cpi	r25, 0x2C	; 44
     af4:	28 f4       	brcc	.+10     	; 0xb00 <vfprintf+0x9a>
     af6:	90 32       	cpi	r25, 0x20	; 32
     af8:	59 f0       	breq	.+22     	; 0xb10 <vfprintf+0xaa>
     afa:	93 32       	cpi	r25, 0x23	; 35
     afc:	91 f4       	brne	.+36     	; 0xb22 <vfprintf+0xbc>
     afe:	0e c0       	rjmp	.+28     	; 0xb1c <vfprintf+0xb6>
     b00:	9d 32       	cpi	r25, 0x2D	; 45
     b02:	49 f0       	breq	.+18     	; 0xb16 <vfprintf+0xb0>
     b04:	90 33       	cpi	r25, 0x30	; 48
     b06:	69 f4       	brne	.+26     	; 0xb22 <vfprintf+0xbc>
     b08:	41 e0       	ldi	r20, 0x01	; 1
     b0a:	2a c0       	rjmp	.+84     	; 0xb60 <vfprintf+0xfa>
     b0c:	52 e0       	ldi	r21, 0x02	; 2
     b0e:	f5 2a       	or	r15, r21
     b10:	84 e0       	ldi	r24, 0x04	; 4
     b12:	f8 2a       	or	r15, r24
     b14:	2e c0       	rjmp	.+92     	; 0xb72 <vfprintf+0x10c>
     b16:	98 e0       	ldi	r25, 0x08	; 8
     b18:	f9 2a       	or	r15, r25
     b1a:	2b c0       	rjmp	.+86     	; 0xb72 <vfprintf+0x10c>
     b1c:	e0 e1       	ldi	r30, 0x10	; 16
     b1e:	fe 2a       	or	r15, r30
     b20:	28 c0       	rjmp	.+80     	; 0xb72 <vfprintf+0x10c>
     b22:	f7 fc       	sbrc	r15, 7
     b24:	33 c0       	rjmp	.+102    	; 0xb8c <vfprintf+0x126>
     b26:	29 2f       	mov	r18, r25
     b28:	20 53       	subi	r18, 0x30	; 48
     b2a:	2a 30       	cpi	r18, 0x0A	; 10
     b2c:	a0 f4       	brcc	.+40     	; 0xb56 <vfprintf+0xf0>
     b2e:	f6 fe       	sbrs	r15, 6
     b30:	08 c0       	rjmp	.+16     	; 0xb42 <vfprintf+0xdc>
     b32:	87 2d       	mov	r24, r7
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	6a e0       	ldi	r22, 0x0A	; 10
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	48 df       	rcall	.-368    	; 0x9cc <__mulhi3>
     b3c:	78 2e       	mov	r7, r24
     b3e:	72 0e       	add	r7, r18
     b40:	18 c0       	rjmp	.+48     	; 0xb72 <vfprintf+0x10c>
     b42:	8e 2d       	mov	r24, r14
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	6a e0       	ldi	r22, 0x0A	; 10
     b48:	70 e0       	ldi	r23, 0x00	; 0
     b4a:	40 df       	rcall	.-384    	; 0x9cc <__mulhi3>
     b4c:	e8 2e       	mov	r14, r24
     b4e:	e2 0e       	add	r14, r18
     b50:	f0 e2       	ldi	r31, 0x20	; 32
     b52:	ff 2a       	or	r15, r31
     b54:	0e c0       	rjmp	.+28     	; 0xb72 <vfprintf+0x10c>
     b56:	9e 32       	cpi	r25, 0x2E	; 46
     b58:	29 f4       	brne	.+10     	; 0xb64 <vfprintf+0xfe>
     b5a:	f6 fc       	sbrc	r15, 6
     b5c:	82 c1       	rjmp	.+772    	; 0xe62 <vfprintf+0x3fc>
     b5e:	40 e4       	ldi	r20, 0x40	; 64
     b60:	f4 2a       	or	r15, r20
     b62:	07 c0       	rjmp	.+14     	; 0xb72 <vfprintf+0x10c>
     b64:	9c 36       	cpi	r25, 0x6C	; 108
     b66:	19 f4       	brne	.+6      	; 0xb6e <vfprintf+0x108>
     b68:	50 e8       	ldi	r21, 0x80	; 128
     b6a:	f5 2a       	or	r15, r21
     b6c:	02 c0       	rjmp	.+4      	; 0xb72 <vfprintf+0x10c>
     b6e:	98 36       	cpi	r25, 0x68	; 104
     b70:	69 f4       	brne	.+26     	; 0xb8c <vfprintf+0x126>
     b72:	e4 2d       	mov	r30, r4
     b74:	f5 2d       	mov	r31, r5
     b76:	33 fd       	sbrc	r19, 3
     b78:	c8 95       	lpm
     b7a:	33 ff       	sbrs	r19, 3
     b7c:	00 80       	ld	r0, Z
     b7e:	31 96       	adiw	r30, 0x01	; 1
     b80:	90 2d       	mov	r25, r0
     b82:	4e 2e       	mov	r4, r30
     b84:	5f 2e       	mov	r5, r31
     b86:	99 23       	and	r25, r25
     b88:	09 f0       	breq	.+2      	; 0xb8c <vfprintf+0x126>
     b8a:	ae cf       	rjmp	.-164    	; 0xae8 <vfprintf+0x82>
     b8c:	89 2f       	mov	r24, r25
     b8e:	85 54       	subi	r24, 0x45	; 69
     b90:	83 30       	cpi	r24, 0x03	; 3
     b92:	18 f0       	brcs	.+6      	; 0xb9a <vfprintf+0x134>
     b94:	80 52       	subi	r24, 0x20	; 32
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	30 f4       	brcc	.+12     	; 0xba6 <vfprintf+0x140>
     b9a:	44 e0       	ldi	r20, 0x04	; 4
     b9c:	50 e0       	ldi	r21, 0x00	; 0
     b9e:	a4 0e       	add	r10, r20
     ba0:	b5 1e       	adc	r11, r21
     ba2:	69 82       	std	Y+1, r6	; 0x01
     ba4:	10 c0       	rjmp	.+32     	; 0xbc6 <vfprintf+0x160>
     ba6:	93 36       	cpi	r25, 0x63	; 99
     ba8:	31 f0       	breq	.+12     	; 0xbb6 <vfprintf+0x150>
     baa:	93 37       	cpi	r25, 0x73	; 115
     bac:	89 f0       	breq	.+34     	; 0xbd0 <vfprintf+0x16a>
     bae:	93 35       	cpi	r25, 0x53	; 83
     bb0:	09 f0       	breq	.+2      	; 0xbb4 <vfprintf+0x14e>
     bb2:	60 c0       	rjmp	.+192    	; 0xc74 <vfprintf+0x20e>
     bb4:	24 c0       	rjmp	.+72     	; 0xbfe <vfprintf+0x198>
     bb6:	ea 2d       	mov	r30, r10
     bb8:	fb 2d       	mov	r31, r11
     bba:	80 81       	ld	r24, Z
     bbc:	89 83       	std	Y+1, r24	; 0x01
     bbe:	42 e0       	ldi	r20, 0x02	; 2
     bc0:	50 e0       	ldi	r21, 0x00	; 0
     bc2:	a4 0e       	add	r10, r20
     bc4:	b5 1e       	adc	r11, r21
     bc6:	c2 2c       	mov	r12, r2
     bc8:	d3 2c       	mov	r13, r3
     bca:	01 e0       	ldi	r16, 0x01	; 1
     bcc:	10 e0       	ldi	r17, 0x00	; 0
     bce:	14 c0       	rjmp	.+40     	; 0xbf8 <vfprintf+0x192>
     bd0:	ea 2d       	mov	r30, r10
     bd2:	fb 2d       	mov	r31, r11
     bd4:	c0 80       	ld	r12, Z
     bd6:	d1 80       	ldd	r13, Z+1	; 0x01
     bd8:	f6 fc       	sbrc	r15, 6
     bda:	03 c0       	rjmp	.+6      	; 0xbe2 <vfprintf+0x17c>
     bdc:	6f ef       	ldi	r22, 0xFF	; 255
     bde:	7f ef       	ldi	r23, 0xFF	; 255
     be0:	02 c0       	rjmp	.+4      	; 0xbe6 <vfprintf+0x180>
     be2:	67 2d       	mov	r22, r7
     be4:	70 e0       	ldi	r23, 0x00	; 0
     be6:	42 e0       	ldi	r20, 0x02	; 2
     be8:	50 e0       	ldi	r21, 0x00	; 0
     bea:	a4 0e       	add	r10, r20
     bec:	b5 1e       	adc	r11, r21
     bee:	8c 2d       	mov	r24, r12
     bf0:	9d 2d       	mov	r25, r13
     bf2:	4d d1       	rcall	.+666    	; 0xe8e <strnlen>
     bf4:	08 2f       	mov	r16, r24
     bf6:	19 2f       	mov	r17, r25
     bf8:	5f e7       	ldi	r21, 0x7F	; 127
     bfa:	f5 22       	and	r15, r21
     bfc:	16 c0       	rjmp	.+44     	; 0xc2a <vfprintf+0x1c4>
     bfe:	ea 2d       	mov	r30, r10
     c00:	fb 2d       	mov	r31, r11
     c02:	c0 80       	ld	r12, Z
     c04:	d1 80       	ldd	r13, Z+1	; 0x01
     c06:	f6 fc       	sbrc	r15, 6
     c08:	03 c0       	rjmp	.+6      	; 0xc10 <vfprintf+0x1aa>
     c0a:	6f ef       	ldi	r22, 0xFF	; 255
     c0c:	7f ef       	ldi	r23, 0xFF	; 255
     c0e:	02 c0       	rjmp	.+4      	; 0xc14 <vfprintf+0x1ae>
     c10:	67 2d       	mov	r22, r7
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	42 e0       	ldi	r20, 0x02	; 2
     c16:	50 e0       	ldi	r21, 0x00	; 0
     c18:	a4 0e       	add	r10, r20
     c1a:	b5 1e       	adc	r11, r21
     c1c:	8c 2d       	mov	r24, r12
     c1e:	9d 2d       	mov	r25, r13
     c20:	29 d1       	rcall	.+594    	; 0xe74 <strnlen_P>
     c22:	08 2f       	mov	r16, r24
     c24:	19 2f       	mov	r17, r25
     c26:	50 e8       	ldi	r21, 0x80	; 128
     c28:	f5 2a       	or	r15, r21
     c2a:	f3 fe       	sbrs	r15, 3
     c2c:	07 c0       	rjmp	.+14     	; 0xc3c <vfprintf+0x1d6>
     c2e:	1e c0       	rjmp	.+60     	; 0xc6c <vfprintf+0x206>
     c30:	80 e2       	ldi	r24, 0x20	; 32
     c32:	90 e0       	ldi	r25, 0x00	; 0
     c34:	68 2d       	mov	r22, r8
     c36:	79 2d       	mov	r23, r9
     c38:	36 d1       	rcall	.+620    	; 0xea6 <fputc>
     c3a:	ea 94       	dec	r14
     c3c:	8e 2d       	mov	r24, r14
     c3e:	90 e0       	ldi	r25, 0x00	; 0
     c40:	08 17       	cp	r16, r24
     c42:	19 07       	cpc	r17, r25
     c44:	a8 f3       	brcs	.-22     	; 0xc30 <vfprintf+0x1ca>
     c46:	12 c0       	rjmp	.+36     	; 0xc6c <vfprintf+0x206>
     c48:	ec 2d       	mov	r30, r12
     c4a:	fd 2d       	mov	r31, r13
     c4c:	f7 fc       	sbrc	r15, 7
     c4e:	c8 95       	lpm
     c50:	f7 fe       	sbrs	r15, 7
     c52:	00 80       	ld	r0, Z
     c54:	31 96       	adiw	r30, 0x01	; 1
     c56:	80 2d       	mov	r24, r0
     c58:	ce 2e       	mov	r12, r30
     c5a:	df 2e       	mov	r13, r31
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	68 2d       	mov	r22, r8
     c60:	79 2d       	mov	r23, r9
     c62:	21 d1       	rcall	.+578    	; 0xea6 <fputc>
     c64:	e1 10       	cpse	r14, r1
     c66:	ea 94       	dec	r14
     c68:	01 50       	subi	r16, 0x01	; 1
     c6a:	10 40       	sbci	r17, 0x00	; 0
     c6c:	01 15       	cp	r16, r1
     c6e:	11 05       	cpc	r17, r1
     c70:	59 f7       	brne	.-42     	; 0xc48 <vfprintf+0x1e2>
     c72:	f4 c0       	rjmp	.+488    	; 0xe5c <vfprintf+0x3f6>
     c74:	94 36       	cpi	r25, 0x64	; 100
     c76:	11 f0       	breq	.+4      	; 0xc7c <vfprintf+0x216>
     c78:	99 36       	cpi	r25, 0x69	; 105
     c7a:	91 f5       	brne	.+100    	; 0xce0 <vfprintf+0x27a>
     c7c:	f7 fe       	sbrs	r15, 7
     c7e:	09 c0       	rjmp	.+18     	; 0xc92 <vfprintf+0x22c>
     c80:	ea 2d       	mov	r30, r10
     c82:	fb 2d       	mov	r31, r11
     c84:	20 81       	ld	r18, Z
     c86:	31 81       	ldd	r19, Z+1	; 0x01
     c88:	42 81       	ldd	r20, Z+2	; 0x02
     c8a:	53 81       	ldd	r21, Z+3	; 0x03
     c8c:	84 e0       	ldi	r24, 0x04	; 4
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	0c c0       	rjmp	.+24     	; 0xcaa <vfprintf+0x244>
     c92:	ea 2d       	mov	r30, r10
     c94:	fb 2d       	mov	r31, r11
     c96:	80 81       	ld	r24, Z
     c98:	91 81       	ldd	r25, Z+1	; 0x01
     c9a:	28 2f       	mov	r18, r24
     c9c:	39 2f       	mov	r19, r25
     c9e:	44 27       	eor	r20, r20
     ca0:	37 fd       	sbrc	r19, 7
     ca2:	40 95       	com	r20
     ca4:	54 2f       	mov	r21, r20
     ca6:	82 e0       	ldi	r24, 0x02	; 2
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	a8 0e       	add	r10, r24
     cac:	b9 1e       	adc	r11, r25
     cae:	9f e6       	ldi	r25, 0x6F	; 111
     cb0:	f9 22       	and	r15, r25
     cb2:	57 ff       	sbrs	r21, 7
     cb4:	09 c0       	rjmp	.+18     	; 0xcc8 <vfprintf+0x262>
     cb6:	50 95       	com	r21
     cb8:	40 95       	com	r20
     cba:	30 95       	com	r19
     cbc:	21 95       	neg	r18
     cbe:	3f 4f       	sbci	r19, 0xFF	; 255
     cc0:	4f 4f       	sbci	r20, 0xFF	; 255
     cc2:	5f 4f       	sbci	r21, 0xFF	; 255
     cc4:	e0 e8       	ldi	r30, 0x80	; 128
     cc6:	fe 2a       	or	r15, r30
     cc8:	95 2f       	mov	r25, r21
     cca:	84 2f       	mov	r24, r20
     ccc:	73 2f       	mov	r23, r19
     cce:	62 2f       	mov	r22, r18
     cd0:	42 2d       	mov	r20, r2
     cd2:	53 2d       	mov	r21, r3
     cd4:	2a e0       	ldi	r18, 0x0A	; 10
     cd6:	30 e0       	ldi	r19, 0x00	; 0
     cd8:	15 d1       	rcall	.+554    	; 0xf04 <__ultoa_invert>
     cda:	d8 2e       	mov	r13, r24
     cdc:	d2 18       	sub	r13, r2
     cde:	43 c0       	rjmp	.+134    	; 0xd66 <vfprintf+0x300>
     ce0:	95 37       	cpi	r25, 0x75	; 117
     ce2:	29 f4       	brne	.+10     	; 0xcee <vfprintf+0x288>
     ce4:	1f 2d       	mov	r17, r15
     ce6:	1f 7e       	andi	r17, 0xEF	; 239
     ce8:	2a e0       	ldi	r18, 0x0A	; 10
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	1d c0       	rjmp	.+58     	; 0xd28 <vfprintf+0x2c2>
     cee:	1f 2d       	mov	r17, r15
     cf0:	19 7f       	andi	r17, 0xF9	; 249
     cf2:	9f 36       	cpi	r25, 0x6F	; 111
     cf4:	61 f0       	breq	.+24     	; 0xd0e <vfprintf+0x2a8>
     cf6:	90 37       	cpi	r25, 0x70	; 112
     cf8:	20 f4       	brcc	.+8      	; 0xd02 <vfprintf+0x29c>
     cfa:	98 35       	cpi	r25, 0x58	; 88
     cfc:	09 f0       	breq	.+2      	; 0xd00 <vfprintf+0x29a>
     cfe:	b1 c0       	rjmp	.+354    	; 0xe62 <vfprintf+0x3fc>
     d00:	0f c0       	rjmp	.+30     	; 0xd20 <vfprintf+0x2ba>
     d02:	90 37       	cpi	r25, 0x70	; 112
     d04:	39 f0       	breq	.+14     	; 0xd14 <vfprintf+0x2ae>
     d06:	98 37       	cpi	r25, 0x78	; 120
     d08:	09 f0       	breq	.+2      	; 0xd0c <vfprintf+0x2a6>
     d0a:	ab c0       	rjmp	.+342    	; 0xe62 <vfprintf+0x3fc>
     d0c:	04 c0       	rjmp	.+8      	; 0xd16 <vfprintf+0x2b0>
     d0e:	28 e0       	ldi	r18, 0x08	; 8
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	0a c0       	rjmp	.+20     	; 0xd28 <vfprintf+0x2c2>
     d14:	10 61       	ori	r17, 0x10	; 16
     d16:	14 fd       	sbrc	r17, 4
     d18:	14 60       	ori	r17, 0x04	; 4
     d1a:	20 e1       	ldi	r18, 0x10	; 16
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	04 c0       	rjmp	.+8      	; 0xd28 <vfprintf+0x2c2>
     d20:	14 fd       	sbrc	r17, 4
     d22:	16 60       	ori	r17, 0x06	; 6
     d24:	20 e1       	ldi	r18, 0x10	; 16
     d26:	32 e0       	ldi	r19, 0x02	; 2
     d28:	17 ff       	sbrs	r17, 7
     d2a:	09 c0       	rjmp	.+18     	; 0xd3e <vfprintf+0x2d8>
     d2c:	ea 2d       	mov	r30, r10
     d2e:	fb 2d       	mov	r31, r11
     d30:	60 81       	ld	r22, Z
     d32:	71 81       	ldd	r23, Z+1	; 0x01
     d34:	82 81       	ldd	r24, Z+2	; 0x02
     d36:	93 81       	ldd	r25, Z+3	; 0x03
     d38:	44 e0       	ldi	r20, 0x04	; 4
     d3a:	50 e0       	ldi	r21, 0x00	; 0
     d3c:	0a c0       	rjmp	.+20     	; 0xd52 <vfprintf+0x2ec>
     d3e:	ea 2d       	mov	r30, r10
     d40:	fb 2d       	mov	r31, r11
     d42:	80 81       	ld	r24, Z
     d44:	91 81       	ldd	r25, Z+1	; 0x01
     d46:	68 2f       	mov	r22, r24
     d48:	79 2f       	mov	r23, r25
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	42 e0       	ldi	r20, 0x02	; 2
     d50:	50 e0       	ldi	r21, 0x00	; 0
     d52:	a4 0e       	add	r10, r20
     d54:	b5 1e       	adc	r11, r21
     d56:	42 2d       	mov	r20, r2
     d58:	53 2d       	mov	r21, r3
     d5a:	d4 d0       	rcall	.+424    	; 0xf04 <__ultoa_invert>
     d5c:	d8 2e       	mov	r13, r24
     d5e:	d2 18       	sub	r13, r2
     d60:	8f e7       	ldi	r24, 0x7F	; 127
     d62:	f8 2e       	mov	r15, r24
     d64:	f1 22       	and	r15, r17
     d66:	f6 fe       	sbrs	r15, 6
     d68:	0b c0       	rjmp	.+22     	; 0xd80 <vfprintf+0x31a>
     d6a:	5e ef       	ldi	r21, 0xFE	; 254
     d6c:	f5 22       	and	r15, r21
     d6e:	d7 14       	cp	r13, r7
     d70:	38 f4       	brcc	.+14     	; 0xd80 <vfprintf+0x31a>
     d72:	f4 fe       	sbrs	r15, 4
     d74:	07 c0       	rjmp	.+14     	; 0xd84 <vfprintf+0x31e>
     d76:	f2 fc       	sbrc	r15, 2
     d78:	05 c0       	rjmp	.+10     	; 0xd84 <vfprintf+0x31e>
     d7a:	8f ee       	ldi	r24, 0xEF	; 239
     d7c:	f8 22       	and	r15, r24
     d7e:	02 c0       	rjmp	.+4      	; 0xd84 <vfprintf+0x31e>
     d80:	1d 2d       	mov	r17, r13
     d82:	01 c0       	rjmp	.+2      	; 0xd86 <vfprintf+0x320>
     d84:	17 2d       	mov	r17, r7
     d86:	f4 fe       	sbrs	r15, 4
     d88:	0e c0       	rjmp	.+28     	; 0xda6 <vfprintf+0x340>
     d8a:	ec 2f       	mov	r30, r28
     d8c:	fd 2f       	mov	r31, r29
     d8e:	ed 0d       	add	r30, r13
     d90:	f1 1d       	adc	r31, r1
     d92:	80 81       	ld	r24, Z
     d94:	80 33       	cpi	r24, 0x30	; 48
     d96:	19 f4       	brne	.+6      	; 0xd9e <vfprintf+0x338>
     d98:	99 ee       	ldi	r25, 0xE9	; 233
     d9a:	f9 22       	and	r15, r25
     d9c:	08 c0       	rjmp	.+16     	; 0xdae <vfprintf+0x348>
     d9e:	1f 5f       	subi	r17, 0xFF	; 255
     da0:	f2 fe       	sbrs	r15, 2
     da2:	05 c0       	rjmp	.+10     	; 0xdae <vfprintf+0x348>
     da4:	03 c0       	rjmp	.+6      	; 0xdac <vfprintf+0x346>
     da6:	8f 2d       	mov	r24, r15
     da8:	86 78       	andi	r24, 0x86	; 134
     daa:	09 f0       	breq	.+2      	; 0xdae <vfprintf+0x348>
     dac:	1f 5f       	subi	r17, 0xFF	; 255
     dae:	0f 2d       	mov	r16, r15
     db0:	f3 fc       	sbrc	r15, 3
     db2:	14 c0       	rjmp	.+40     	; 0xddc <vfprintf+0x376>
     db4:	f0 fe       	sbrs	r15, 0
     db6:	0f c0       	rjmp	.+30     	; 0xdd6 <vfprintf+0x370>
     db8:	1e 15       	cp	r17, r14
     dba:	10 f0       	brcs	.+4      	; 0xdc0 <vfprintf+0x35a>
     dbc:	7d 2c       	mov	r7, r13
     dbe:	0b c0       	rjmp	.+22     	; 0xdd6 <vfprintf+0x370>
     dc0:	7d 2c       	mov	r7, r13
     dc2:	7e 0c       	add	r7, r14
     dc4:	71 1a       	sub	r7, r17
     dc6:	1e 2d       	mov	r17, r14
     dc8:	06 c0       	rjmp	.+12     	; 0xdd6 <vfprintf+0x370>
     dca:	80 e2       	ldi	r24, 0x20	; 32
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	68 2d       	mov	r22, r8
     dd0:	79 2d       	mov	r23, r9
     dd2:	69 d0       	rcall	.+210    	; 0xea6 <fputc>
     dd4:	1f 5f       	subi	r17, 0xFF	; 255
     dd6:	1e 15       	cp	r17, r14
     dd8:	c0 f3       	brcs	.-16     	; 0xdca <vfprintf+0x364>
     dda:	04 c0       	rjmp	.+8      	; 0xde4 <vfprintf+0x37e>
     ddc:	1e 15       	cp	r17, r14
     dde:	10 f4       	brcc	.+4      	; 0xde4 <vfprintf+0x37e>
     de0:	e1 1a       	sub	r14, r17
     de2:	01 c0       	rjmp	.+2      	; 0xde6 <vfprintf+0x380>
     de4:	ee 24       	eor	r14, r14
     de6:	04 ff       	sbrs	r16, 4
     de8:	0f c0       	rjmp	.+30     	; 0xe08 <vfprintf+0x3a2>
     dea:	80 e3       	ldi	r24, 0x30	; 48
     dec:	90 e0       	ldi	r25, 0x00	; 0
     dee:	68 2d       	mov	r22, r8
     df0:	79 2d       	mov	r23, r9
     df2:	59 d0       	rcall	.+178    	; 0xea6 <fputc>
     df4:	02 ff       	sbrs	r16, 2
     df6:	1d c0       	rjmp	.+58     	; 0xe32 <vfprintf+0x3cc>
     df8:	01 fd       	sbrc	r16, 1
     dfa:	03 c0       	rjmp	.+6      	; 0xe02 <vfprintf+0x39c>
     dfc:	88 e7       	ldi	r24, 0x78	; 120
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	0e c0       	rjmp	.+28     	; 0xe1e <vfprintf+0x3b8>
     e02:	88 e5       	ldi	r24, 0x58	; 88
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	0b c0       	rjmp	.+22     	; 0xe1e <vfprintf+0x3b8>
     e08:	80 2f       	mov	r24, r16
     e0a:	86 78       	andi	r24, 0x86	; 134
     e0c:	91 f0       	breq	.+36     	; 0xe32 <vfprintf+0x3cc>
     e0e:	01 ff       	sbrs	r16, 1
     e10:	02 c0       	rjmp	.+4      	; 0xe16 <vfprintf+0x3b0>
     e12:	8b e2       	ldi	r24, 0x2B	; 43
     e14:	01 c0       	rjmp	.+2      	; 0xe18 <vfprintf+0x3b2>
     e16:	80 e2       	ldi	r24, 0x20	; 32
     e18:	f7 fc       	sbrc	r15, 7
     e1a:	8d e2       	ldi	r24, 0x2D	; 45
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	68 2d       	mov	r22, r8
     e20:	79 2d       	mov	r23, r9
     e22:	41 d0       	rcall	.+130    	; 0xea6 <fputc>
     e24:	06 c0       	rjmp	.+12     	; 0xe32 <vfprintf+0x3cc>
     e26:	80 e3       	ldi	r24, 0x30	; 48
     e28:	90 e0       	ldi	r25, 0x00	; 0
     e2a:	68 2d       	mov	r22, r8
     e2c:	79 2d       	mov	r23, r9
     e2e:	3b d0       	rcall	.+118    	; 0xea6 <fputc>
     e30:	7a 94       	dec	r7
     e32:	d7 14       	cp	r13, r7
     e34:	c0 f3       	brcs	.-16     	; 0xe26 <vfprintf+0x3c0>
     e36:	da 94       	dec	r13
     e38:	e2 2d       	mov	r30, r2
     e3a:	f3 2d       	mov	r31, r3
     e3c:	ed 0d       	add	r30, r13
     e3e:	f1 1d       	adc	r31, r1
     e40:	80 81       	ld	r24, Z
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	68 2d       	mov	r22, r8
     e46:	79 2d       	mov	r23, r9
     e48:	2e d0       	rcall	.+92     	; 0xea6 <fputc>
     e4a:	dd 20       	and	r13, r13
     e4c:	a1 f7       	brne	.-24     	; 0xe36 <vfprintf+0x3d0>
     e4e:	06 c0       	rjmp	.+12     	; 0xe5c <vfprintf+0x3f6>
     e50:	80 e2       	ldi	r24, 0x20	; 32
     e52:	90 e0       	ldi	r25, 0x00	; 0
     e54:	68 2d       	mov	r22, r8
     e56:	79 2d       	mov	r23, r9
     e58:	26 d0       	rcall	.+76     	; 0xea6 <fputc>
     e5a:	ea 94       	dec	r14
     e5c:	ee 20       	and	r14, r14
     e5e:	c1 f7       	brne	.-16     	; 0xe50 <vfprintf+0x3ea>
     e60:	1e ce       	rjmp	.-964    	; 0xa9e <vfprintf+0x38>
     e62:	e8 2d       	mov	r30, r8
     e64:	f9 2d       	mov	r31, r9
     e66:	66 81       	ldd	r22, Z+6	; 0x06
     e68:	77 81       	ldd	r23, Z+7	; 0x07
     e6a:	86 2f       	mov	r24, r22
     e6c:	97 2f       	mov	r25, r23
     e6e:	2b 96       	adiw	r28, 0x0b	; 11
     e70:	e2 e1       	ldi	r30, 0x12	; 18
     e72:	c8 c0       	rjmp	.+400    	; 0x1004 <__epilogue_restores__>

00000e74 <strnlen_P>:
     e74:	e8 2f       	mov	r30, r24
     e76:	f9 2f       	mov	r31, r25
     e78:	c8 95       	lpm
     e7a:	31 96       	adiw	r30, 0x01	; 1
     e7c:	61 50       	subi	r22, 0x01	; 1
     e7e:	70 40       	sbci	r23, 0x00	; 0
     e80:	01 10       	cpse	r0, r1
     e82:	d0 f7       	brcc	.-12     	; 0xe78 <strnlen_P+0x4>
     e84:	80 95       	com	r24
     e86:	90 95       	com	r25
     e88:	8e 0f       	add	r24, r30
     e8a:	9f 1f       	adc	r25, r31
     e8c:	08 95       	ret

00000e8e <strnlen>:
     e8e:	e8 2f       	mov	r30, r24
     e90:	f9 2f       	mov	r31, r25
     e92:	61 50       	subi	r22, 0x01	; 1
     e94:	70 40       	sbci	r23, 0x00	; 0
     e96:	01 90       	ld	r0, Z+
     e98:	01 10       	cpse	r0, r1
     e9a:	d8 f7       	brcc	.-10     	; 0xe92 <strnlen+0x4>
     e9c:	80 95       	com	r24
     e9e:	90 95       	com	r25
     ea0:	8e 0f       	add	r24, r30
     ea2:	9f 1f       	adc	r25, r31
     ea4:	08 95       	ret

00000ea6 <fputc>:
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	cf 93       	push	r28
     eac:	df 93       	push	r29
     eae:	08 2f       	mov	r16, r24
     eb0:	19 2f       	mov	r17, r25
     eb2:	c6 2f       	mov	r28, r22
     eb4:	d7 2f       	mov	r29, r23
     eb6:	8b 81       	ldd	r24, Y+3	; 0x03
     eb8:	81 ff       	sbrs	r24, 1
     eba:	1b c0       	rjmp	.+54     	; 0xef2 <fputc+0x4c>
     ebc:	82 ff       	sbrs	r24, 2
     ebe:	0d c0       	rjmp	.+26     	; 0xeda <fputc+0x34>
     ec0:	2e 81       	ldd	r18, Y+6	; 0x06
     ec2:	3f 81       	ldd	r19, Y+7	; 0x07
     ec4:	8c 81       	ldd	r24, Y+4	; 0x04
     ec6:	9d 81       	ldd	r25, Y+5	; 0x05
     ec8:	28 17       	cp	r18, r24
     eca:	39 07       	cpc	r19, r25
     ecc:	64 f4       	brge	.+24     	; 0xee6 <fputc+0x40>
     ece:	e8 81       	ld	r30, Y
     ed0:	f9 81       	ldd	r31, Y+1	; 0x01
     ed2:	01 93       	st	Z+, r16
     ed4:	f9 83       	std	Y+1, r31	; 0x01
     ed6:	e8 83       	st	Y, r30
     ed8:	06 c0       	rjmp	.+12     	; 0xee6 <fputc+0x40>
     eda:	e8 85       	ldd	r30, Y+8	; 0x08
     edc:	f9 85       	ldd	r31, Y+9	; 0x09
     ede:	80 2f       	mov	r24, r16
     ee0:	09 95       	icall
     ee2:	89 2b       	or	r24, r25
     ee4:	31 f4       	brne	.+12     	; 0xef2 <fputc+0x4c>
     ee6:	8e 81       	ldd	r24, Y+6	; 0x06
     ee8:	9f 81       	ldd	r25, Y+7	; 0x07
     eea:	01 96       	adiw	r24, 0x01	; 1
     eec:	9f 83       	std	Y+7, r25	; 0x07
     eee:	8e 83       	std	Y+6, r24	; 0x06
     ef0:	02 c0       	rjmp	.+4      	; 0xef6 <fputc+0x50>
     ef2:	0f ef       	ldi	r16, 0xFF	; 255
     ef4:	1f ef       	ldi	r17, 0xFF	; 255
     ef6:	80 2f       	mov	r24, r16
     ef8:	91 2f       	mov	r25, r17
     efa:	df 91       	pop	r29
     efc:	cf 91       	pop	r28
     efe:	1f 91       	pop	r17
     f00:	0f 91       	pop	r16
     f02:	08 95       	ret

00000f04 <__ultoa_invert>:
     f04:	e4 2f       	mov	r30, r20
     f06:	f5 2f       	mov	r31, r21
     f08:	aa 27       	eor	r26, r26
     f0a:	28 30       	cpi	r18, 0x08	; 8
     f0c:	69 f1       	breq	.+90     	; 0xf68 <__ultoa_invert+0x64>
     f0e:	20 31       	cpi	r18, 0x10	; 16
     f10:	99 f1       	breq	.+102    	; 0xf78 <__ultoa_invert+0x74>
     f12:	e8 94       	clt
     f14:	6f 93       	push	r22
     f16:	6e 7f       	andi	r22, 0xFE	; 254
     f18:	6e 5f       	subi	r22, 0xFE	; 254
     f1a:	7f 4f       	sbci	r23, 0xFF	; 255
     f1c:	8f 4f       	sbci	r24, 0xFF	; 255
     f1e:	9f 4f       	sbci	r25, 0xFF	; 255
     f20:	af 4f       	sbci	r26, 0xFF	; 255
     f22:	b1 e0       	ldi	r27, 0x01	; 1
     f24:	41 d0       	rcall	.+130    	; 0xfa8 <__ultoa_invert+0xa4>
     f26:	b4 e0       	ldi	r27, 0x04	; 4
     f28:	3f d0       	rcall	.+126    	; 0xfa8 <__ultoa_invert+0xa4>
     f2a:	67 0f       	add	r22, r23
     f2c:	78 1f       	adc	r23, r24
     f2e:	89 1f       	adc	r24, r25
     f30:	9a 1f       	adc	r25, r26
     f32:	a1 1d       	adc	r26, r1
     f34:	68 0f       	add	r22, r24
     f36:	79 1f       	adc	r23, r25
     f38:	8a 1f       	adc	r24, r26
     f3a:	91 1d       	adc	r25, r1
     f3c:	a1 1d       	adc	r26, r1
     f3e:	6a 0f       	add	r22, r26
     f40:	71 1d       	adc	r23, r1
     f42:	81 1d       	adc	r24, r1
     f44:	91 1d       	adc	r25, r1
     f46:	a1 1d       	adc	r26, r1
     f48:	23 d0       	rcall	.+70     	; 0xf90 <__ultoa_invert+0x8c>
     f4a:	09 f4       	brne	.+2      	; 0xf4e <__ultoa_invert+0x4a>
     f4c:	68 94       	set
     f4e:	3f 91       	pop	r19
     f50:	06 2e       	mov	r0, r22
     f52:	00 0c       	add	r0, r0
     f54:	30 19       	sub	r19, r0
     f56:	00 0c       	add	r0, r0
     f58:	00 0c       	add	r0, r0
     f5a:	30 19       	sub	r19, r0
     f5c:	30 5d       	subi	r19, 0xD0	; 208
     f5e:	31 93       	st	Z+, r19
     f60:	ce f6       	brtc	.-78     	; 0xf14 <__ultoa_invert+0x10>
     f62:	8e 2f       	mov	r24, r30
     f64:	9f 2f       	mov	r25, r31
     f66:	08 95       	ret
     f68:	46 2f       	mov	r20, r22
     f6a:	47 70       	andi	r20, 0x07	; 7
     f6c:	40 5d       	subi	r20, 0xD0	; 208
     f6e:	41 93       	st	Z+, r20
     f70:	b3 e0       	ldi	r27, 0x03	; 3
     f72:	0f d0       	rcall	.+30     	; 0xf92 <__ultoa_invert+0x8e>
     f74:	c9 f7       	brne	.-14     	; 0xf68 <__ultoa_invert+0x64>
     f76:	f5 cf       	rjmp	.-22     	; 0xf62 <__ultoa_invert+0x5e>
     f78:	46 2f       	mov	r20, r22
     f7a:	4f 70       	andi	r20, 0x0F	; 15
     f7c:	40 5d       	subi	r20, 0xD0	; 208
     f7e:	4a 33       	cpi	r20, 0x3A	; 58
     f80:	18 f0       	brcs	.+6      	; 0xf88 <__ultoa_invert+0x84>
     f82:	49 5d       	subi	r20, 0xD9	; 217
     f84:	31 fd       	sbrc	r19, 1
     f86:	40 52       	subi	r20, 0x20	; 32
     f88:	41 93       	st	Z+, r20
     f8a:	02 d0       	rcall	.+4      	; 0xf90 <__ultoa_invert+0x8c>
     f8c:	a9 f7       	brne	.-22     	; 0xf78 <__ultoa_invert+0x74>
     f8e:	e9 cf       	rjmp	.-46     	; 0xf62 <__ultoa_invert+0x5e>
     f90:	b4 e0       	ldi	r27, 0x04	; 4
     f92:	a6 95       	lsr	r26
     f94:	97 95       	ror	r25
     f96:	87 95       	ror	r24
     f98:	77 95       	ror	r23
     f9a:	67 95       	ror	r22
     f9c:	ba 95       	dec	r27
     f9e:	c9 f7       	brne	.-14     	; 0xf92 <__ultoa_invert+0x8e>
     fa0:	00 97       	sbiw	r24, 0x00	; 0
     fa2:	61 05       	cpc	r22, r1
     fa4:	71 05       	cpc	r23, r1
     fa6:	08 95       	ret
     fa8:	26 2f       	mov	r18, r22
     faa:	37 2f       	mov	r19, r23
     fac:	48 2f       	mov	r20, r24
     fae:	59 2f       	mov	r21, r25
     fb0:	0a 2e       	mov	r0, r26
     fb2:	06 94       	lsr	r0
     fb4:	57 95       	ror	r21
     fb6:	47 95       	ror	r20
     fb8:	37 95       	ror	r19
     fba:	27 95       	ror	r18
     fbc:	ba 95       	dec	r27
     fbe:	c9 f7       	brne	.-14     	; 0xfb2 <__ultoa_invert+0xae>
     fc0:	62 0f       	add	r22, r18
     fc2:	73 1f       	adc	r23, r19
     fc4:	84 1f       	adc	r24, r20
     fc6:	95 1f       	adc	r25, r21
     fc8:	a0 1d       	adc	r26, r0
     fca:	08 95       	ret

00000fcc <__prologue_saves__>:
     fcc:	2f 92       	push	r2
     fce:	3f 92       	push	r3
     fd0:	4f 92       	push	r4
     fd2:	5f 92       	push	r5
     fd4:	6f 92       	push	r6
     fd6:	7f 92       	push	r7
     fd8:	8f 92       	push	r8
     fda:	9f 92       	push	r9
     fdc:	af 92       	push	r10
     fde:	bf 92       	push	r11
     fe0:	cf 92       	push	r12
     fe2:	df 92       	push	r13
     fe4:	ef 92       	push	r14
     fe6:	ff 92       	push	r15
     fe8:	0f 93       	push	r16
     fea:	1f 93       	push	r17
     fec:	cf 93       	push	r28
     fee:	df 93       	push	r29
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	ca 1b       	sub	r28, r26
     ff6:	db 0b       	sbc	r29, r27
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	f8 94       	cli
     ffc:	de bf       	out	0x3e, r29	; 62
     ffe:	0f be       	out	0x3f, r0	; 63
    1000:	cd bf       	out	0x3d, r28	; 61
    1002:	09 94       	ijmp

00001004 <__epilogue_restores__>:
    1004:	2a 88       	ldd	r2, Y+18	; 0x12
    1006:	39 88       	ldd	r3, Y+17	; 0x11
    1008:	48 88       	ldd	r4, Y+16	; 0x10
    100a:	5f 84       	ldd	r5, Y+15	; 0x0f
    100c:	6e 84       	ldd	r6, Y+14	; 0x0e
    100e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1010:	8c 84       	ldd	r8, Y+12	; 0x0c
    1012:	9b 84       	ldd	r9, Y+11	; 0x0b
    1014:	aa 84       	ldd	r10, Y+10	; 0x0a
    1016:	b9 84       	ldd	r11, Y+9	; 0x09
    1018:	c8 84       	ldd	r12, Y+8	; 0x08
    101a:	df 80       	ldd	r13, Y+7	; 0x07
    101c:	ee 80       	ldd	r14, Y+6	; 0x06
    101e:	fd 80       	ldd	r15, Y+5	; 0x05
    1020:	0c 81       	ldd	r16, Y+4	; 0x04
    1022:	1b 81       	ldd	r17, Y+3	; 0x03
    1024:	aa 81       	ldd	r26, Y+2	; 0x02
    1026:	b9 81       	ldd	r27, Y+1	; 0x01
    1028:	ce 0f       	add	r28, r30
    102a:	d1 1d       	adc	r29, r1
    102c:	0f b6       	in	r0, 0x3f	; 63
    102e:	f8 94       	cli
    1030:	de bf       	out	0x3e, r29	; 62
    1032:	0f be       	out	0x3f, r0	; 63
    1034:	cd bf       	out	0x3d, r28	; 61
    1036:	ca 2f       	mov	r28, r26
    1038:	db 2f       	mov	r29, r27
    103a:	08 95       	ret

0000103c <_exit>:
    103c:	f8 94       	cli

0000103e <__stop_program>:
    103e:	ff cf       	rjmp	.-2      	; 0x103e <__stop_program>
